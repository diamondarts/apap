*&---------------------------------------------------------------------*
*& Report  ZAPAP                                                       *
*&                                                                     *
*&---------------------------------------------------------------------*
*
* APAP - Generate javadoc-style documentation for SAP repository objects
* Copyright (C) 2007  Björn Harmen Gerth
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the
* Free Software Foundation, Inc.
* 51 Franklin Street
* Fifth Floor
* Boston, MA 02110-1301
* USA
*&---------------------------------------------------------------------*

REPORT zapap NO STANDARD PAGE HEADING LINE-SIZE 255.

DEFINE transl.
  if ic_name eq &1.
    check &2 ne space.
    ec_name = &2.
  endif.
END-OF-DEFINITION.

TYPES:
  BEGIN OF ys_selopt,
    sign   TYPE bapisign,
    option TYPE bapioption,
    low    TYPE tadir-object,
    high   TYPE tadir-object,
  END OF ys_selopt,
  yl_selopt TYPE TABLE OF ys_selopt,
  yl_devc   TYPE TABLE OF tdevc-devclass.

*----------------------------------------------------------------------*
*       CLASS ycl_generator DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ycl_generator DEFINITION.

  PUBLIC SECTION.
    TYPE-POOLS:
      abap,
      seoc,
      seor,
      seos.

    DATA:
      mt_output   TYPE sotr_texts,
      mr_output   TYPE REF TO string,
      mt_tags     TYPE sotr_texts,
      mc_langu    TYPE sy-langu,
      mt_selopt   TYPE yl_selopt,
      mt_packages TYPE yl_devc,
      mb_recurse  TYPE abap_bool.

    METHODS:
      constructor
        IMPORTING
          ic_langu   TYPE sy-langu
          it_selopt  TYPE yl_selopt OPTIONAL
          ib_recurse TYPE abap_bool DEFAULT abap_false,
     process_packages
       IMPORTING it_packages TYPE yl_devc,
     process_clas
       IMPORTING ic_name TYPE c,
     process_devc
       IMPORTING ic_name TYPE c,
     process_dtel
       IMPORTING ic_name TYPE c,
     process_doma
       IMPORTING ic_name TYPE c,
     process_fugr
       IMPORTING ic_name TYPE c,
     process_func
       IMPORTING ic_name TYPE c,
     process_enqu
       IMPORTING ic_name TYPE c,
     process_intf
       IMPORTING ic_name TYPE c,
     process_tabl
       IMPORTING ic_name TYPE c,
     process_ttyp
       IMPORTING ic_name TYPE c.

  PROTECTED SECTION.
    TYPES BEGIN OF ys_attrdescr.
    INCLUDE TYPE abap_attrdescr.
    TYPES description TYPE string.
    TYPES END OF ys_attrdescr.
    TYPES BEGIN OF ys_methdescr.
    INCLUDE TYPE abap_methdescr.
    TYPES description TYPE string.
    TYPES END OF ys_methdescr.
    TYPES BEGIN OF ys_parmdescr.
    INCLUDE TYPE abap_parmdescr.
    TYPES description TYPE string.
    TYPES END OF ys_parmdescr.
    TYPES BEGIN OF ys_excpdescr.
    INCLUDE TYPE abap_excpdescr.
    TYPES description TYPE string.
    TYPES END OF ys_excpdescr.
    TYPES BEGIN OF ys_evntdescr.
    INCLUDE TYPE abap_evntdescr.
    TYPES description TYPE string.
    TYPES END OF ys_evntdescr.

    METHODS:
      process_object_body
        IMPORTING ic_name  TYPE c,
      process_parameter
        IMPORTING
          ic_function  TYPE c
          ic_tag       TYPE string
          it_docu      TYPE rsfb_fdo
          it_parameter TYPE STANDARD TABLE
          ic_parmkind  TYPE funct-kind DEFAULT 'P'
        CHANGING
          cs_wa        TYPE any,
      process_documentation
        IMPORTING
          ic_name  TYPE c
          ic_dokid TYPE c
          ic_type  TYPE dokhl-typ DEFAULT 'E',
      get_attribute_value
        IMPORTING
          ic_name  TYPE any
          i_field  TYPE any
        RETURNING
          value(ec_value) TYPE string,
      convert_entities
        IMPORTING ic_value TYPE any
        RETURNING value(ec_value) TYPE string,
      get_attribute_name
        IMPORTING ic_name TYPE c
        RETURNING value(ec_name) TYPE string,
      write_attribute
        IMPORTING ic_name TYPE c i_field TYPE any
        RETURNING value(ec_attribute) TYPE string,
      write_attributes
        IMPORTING is_struc TYPE any
        RETURNING value(ec_attr) TYPE string,
      end_tag,
      get_tag RETURNING value(ec_tag) TYPE string,
      write_tag
        IMPORTING
          ic_tag   TYPE string
          is_struc TYPE any OPTIONAL
          ib_end   TYPE abap_bool DEFAULT abap_true,
      write_table
        IMPORTING
          ic_tag   TYPE string
          it_table TYPE ANY TABLE,
      get_table_content
        IMPORTING ic_name TYPE c,
      get_superclass
        IMPORTING ic_classname TYPE any
        RETURNING value(ec_superclass) TYPE seoclsname.
ENDCLASS.                    "ycl_generator DEFINITION

DATA gc_devc   TYPE tdevc-devclass.
PARAMETERS:
* text: 'Application name'
  p_appl       TYPE cvers_ref-desc_text.
SELECT-OPTIONS:
* text from ddic
  s_devcls     FOR gc_devc OBLIGATORY.
PARAMETERS:
* text: 'Recursively select subpackages'
  p_recurs     TYPE abap_bool AS CHECKBOX,
* text: 'Language'
  p_langu      TYPE sy-langu  DEFAULT sy-langu,
* text: 'Download to'
  p_file       TYPE rlgrap-filename.

* Add all supported repository objects here
SELECTION-SCREEN BEGIN OF BLOCK bl1 WITH FRAME TITLE text-rep.
PARAMETERS:
* text: 'Table / structure'
  p_tabl   TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN BEGIN OF BLOCK bl2 WITH FRAME.
PARAMETERS:
* text: 'Include system table content'
  p_syscnt TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN END OF BLOCK bl2.
PARAMETERS:
* text: 'Table type'
  p_ttyp   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: 'Data element'
  p_dtel   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: 'Domain'
  p_doma   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: 'Enqueue object'
  p_enqu   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: 'Class'
  p_clas   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: 'Interface'
  p_intf   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: 'Function group'
  p_fugr   TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN END OF BLOCK bl1.

DATA:
  gr_generator TYPE REF TO ycl_generator,
  gt_selopt    TYPE TABLE OF ys_selopt,
  gs_selopt    LIKE LINE OF gt_selopt,
  gt_packages  TYPE yl_devc,
  gc_file      TYPE string,
  gc_path      TYPE string,
  gc_fullpath  TYPE string,
  gi_action    TYPE i.
FIELD-SYMBOLS:
  <t>          LIKE LINE OF gr_generator->mt_output.



*-----------------------------------------------------------------------
* Display a file picker window
*-----------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.

  CALL METHOD cl_gui_frontend_services=>file_save_dialog
    EXPORTING
*      WINDOW_TITLE         =
       default_extension    = 'xml'
*      DEFAULT_FILE_NAME    =
       file_filter          = '*.xml'
*      INITIAL_DIRECTORY    =
*      WITH_ENCODING        =
*      PROMPT_ON_OVERWRITE  = 'X'
    CHANGING
      filename             = gc_file
      path                 = gc_path
      fullpath             = gc_fullpath
      user_action          = gi_action
    EXCEPTIONS
      OTHERS               = 1.
  IF sy-subrc NE 0.
    WRITE: / 'An error has occured picking a file'.
    EXIT.
  ENDIF.

  IF gi_action EQ cl_gui_frontend_services=>action_ok.
    p_file = gc_fullpath.
  ENDIF.



START-OF-SELECTION.

* Add all supported repository objects here
  gs_selopt-sign   = 'I'.
  gs_selopt-option = 'EQ'.
  IF p_tabl EQ abap_true.
    gs_selopt-low    = 'TABL'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_ttyp EQ abap_true.
    gs_selopt-low    = 'TTYP'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_dtel EQ abap_true.
    gs_selopt-low    = 'DTEL'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_doma EQ abap_true.
    gs_selopt-low    = 'DOMA'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_enqu EQ abap_true.
    gs_selopt-low    = 'ENQU'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_clas EQ abap_true.
    gs_selopt-low    = 'CLAS'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_intf EQ abap_true.
    gs_selopt-low    = 'INTF'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF p_fugr EQ abap_true.
    gs_selopt-low    = 'FUGR'.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.
  IF gt_selopt IS INITIAL.
*   Add a dummy select option. Otherwise the table is empty, which would
*   result in the selection of ALL possible repository objects.
    gs_selopt-low    = space.
    APPEND gs_selopt TO gt_selopt.
  ENDIF.


  CREATE OBJECT gr_generator EXPORTING ic_langu   = p_langu
                                       it_selopt  = gt_selopt
                                       ib_recurse = p_recurs.

  APPEND '<?xml version="1.0" encoding="UTF-8"?>'
  TO gr_generator->mt_output.
  IF p_appl IS INITIAL.
    APPEND '<application>' TO gr_generator->mt_output.
  ELSE.
    CLEAR gc_file.
    CONCATENATE '<application name="' p_appl '">' INTO gc_file.
    APPEND gc_file TO gr_generator->mt_output.
  ENDIF.

  SELECT devclass FROM tdevc
            INTO TABLE gt_packages
                 WHERE devclass IN s_devcls.
  CALL METHOD gr_generator->process_packages( gt_packages ).

  APPEND '</application>' TO gr_generator->mt_output.


  LOOP AT gr_generator->mt_output ASSIGNING <t>.
    WRITE / <t>.
  ENDLOOP.

  IF NOT p_file IS INITIAL.
    gc_fullpath = p_file.
    CALL METHOD cl_gui_frontend_services=>gui_download
      EXPORTING
        filename = gc_fullpath
      CHANGING
        data_tab = gr_generator->mt_output
      EXCEPTIONS
        OTHERS   = 0.
  ENDIF.



*----------------------------------------------------------------------*
*       CLASS ycl_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ycl_generator IMPLEMENTATION.

  METHOD constructor.

    FIELD-SYMBOLS <s> LIKE LINE OF mt_selopt.

    mc_langu   = ic_langu.
    mt_selopt  = it_selopt.
    mb_recurse = ib_recurse.

*   The TADIR entry of a package XY contains itself as development class
*   => endless loop, so exclude package from selection
    INSERT INITIAL LINE INTO mt_selopt INDEX 1 ASSIGNING <s>.
    <s>-sign   = 'E'.
    <s>-option = 'EQ'.
    <s>-low    = 'DEVC'.

  ENDMETHOD.                    "constructor

  METHOD process_packages.

    FIELD-SYMBOLS <p> LIKE LINE OF mt_packages.

    mt_packages = it_packages.
    LOOP AT mt_packages ASSIGNING <p>.
      CALL METHOD process_devc( <p> ).
    ENDLOOP.

  ENDMETHOD.                    "process_packages

  METHOD process_clas.

    DATA:
      BEGIN OF ls_spr,
        clsname     TYPE seoclskey-clsname,
*       This will be useful for sorting the superclass by distance
*       to the actual class
        dist        TYPE sy-index,
      END OF ls_spr,
      ls_clskey     TYPE seoclskey,
      ls_class      TYPE seoc_class_r,
      lt_subclasses TYPE seor_inheritance_keys.

    ls_clskey-clsname = ic_name.
    CALL FUNCTION 'SEO_CLASS_READ'
      EXPORTING
        clskey          = ls_clskey
        version         = seoc_version_active
        master_language = space
        modif_language  = mc_langu
      IMPORTING
        class           = ls_class.
    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'class'
        is_struc = ls_class
        ib_end   = abap_false.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = 'CL'.

    ls_spr-clsname = ic_name.
    DO.
      ls_spr-dist = sy-index.
      ls_spr-clsname = get_superclass( ls_spr-clsname ).
      IF ls_spr-clsname IS INITIAL. EXIT. ENDIF.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'superclass'
          is_struc = ls_spr.
    ENDDO.

    CALL FUNCTION 'SEO_CLASS_GET_ALL_SUBS'
      EXPORTING
        clskey  = ls_clskey
      IMPORTING
        inhkeys = lt_subclasses
      EXCEPTIONS
        OTHERS  = 0.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = 'subclass'
        it_table = lt_subclasses.

    CALL METHOD process_object_body
      EXPORTING
        ic_name = ic_name.

    CALL METHOD end_tag. "class

  ENDMETHOD.                    "process_clas




  METHOD process_devc.

    DATA:
      ls_tadir    TYPE tadir,
      ls_tdevc    TYPE tdevc,
      lc_devclass TYPE tdevc-devclass.


    CALL FUNCTION 'TR_DEVCLASS_GET'
      EXPORTING
        iv_devclass = ic_name
        iv_langu    = mc_langu
      IMPORTING
        es_tdevc    = ls_tdevc
      EXCEPTIONS
        OTHERS      = 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'package'
        is_struc = ls_tdevc
        ib_end   = abap_false.


*   list all subpackages with descriptions
    SELECT devclass FROM tdevc
                    INTO lc_devclass
                   WHERE parentcl EQ ic_name.
      CALL FUNCTION 'TR_DEVCLASS_GET'
        EXPORTING
          iv_devclass = lc_devclass
          iv_langu    = mc_langu
        IMPORTING
          es_tdevc    = ls_tdevc
        EXCEPTIONS
          OTHERS      = 0.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'subpackage'
          is_struc = ls_tdevc.

*     If recursion is enabled, append subpackages to package list if
*     not yet included
      IF mb_recurse EQ abap_true.
        COLLECT lc_devclass INTO mt_packages.
      ENDIF.
    ENDSELECT.

*   Process all contained repository objects
    SELECT * FROM tadir
             INTO ls_tadir
            WHERE object   IN mt_selopt
              AND devclass EQ ic_name.
      CASE ls_tadir-object.
        WHEN 'CLAS'.
          CALL METHOD process_clas
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN 'DOMA'.
          CALL METHOD process_doma
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN 'DTEL'.
          CALL METHOD process_dtel
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN 'ENQU'.
          CALL METHOD process_enqu
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN 'FUGR'.
          CALL METHOD process_fugr
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN 'INTF'.
          CALL METHOD process_intf
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN 'TABL'.
          CALL METHOD process_tabl
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN 'TTYP'.
          CALL METHOD process_ttyp
            EXPORTING
              ic_name = ls_tadir-obj_name.
      ENDCASE.
    ENDSELECT.

    CALL METHOD end_tag.

  ENDMETHOD.                    "process_package


  METHOD process_doma.

    DATA:
      lc_name TYPE ddobjname,
      ls_dd01 TYPE dd01v,
      lt_dd07 TYPE TABLE OF dd07v.

    lc_name = ic_name.
    CALL FUNCTION 'DDIF_DOMA_GET'
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd01v_wa  = ls_dd01
      TABLES
        dd07v_tab = lt_dd07
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd01 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'domain'
        is_struc = ls_dd01
        ib_end   = abap_false.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = 'fixed-value'
        it_table = lt_dd07.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = 'DO'
        ic_type  = 'T'.

    CALL METHOD end_tag.

  ENDMETHOD.                    "process_domain


  METHOD process_dtel.

    DATA:
      lc_name TYPE ddobjname,
      ls_dd04 TYPE dd04v.

    lc_name = ic_name.
    CALL FUNCTION 'DDIF_DTEL_GET'
      EXPORTING
        name                = lc_name
       langu               = mc_langu
     IMPORTING
       dd04v_wa            = ls_dd04
*     TPARA_WA            =
     EXCEPTIONS
       OTHERS              = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd04 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'dataelem'
        is_struc = ls_dd04
        ib_end   = abap_false.
    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = 'DE'.
    CALL METHOD end_tag.


  ENDMETHOD.                    "process_dataelem


  METHOD process_enqu.

    DATA:
      lc_name    TYPE ddobjname,
      ls_dd25    TYPE dd25v,
      lt_dd26    TYPE TABLE OF dd26e,
      lt_dd27    TYPE TABLE OF dd27p,
      lt_dden    TYPE TABLE OF ddena.

    lc_name = ic_name.
    CALL FUNCTION 'DDIF_ENQU_GET'
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd25v_wa  = ls_dd25
      TABLES
        dd26e_tab = lt_dd26
        dd27p_tab = lt_dd27
        ddena_tab = lt_dden
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd25 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'enqueue-object'
        is_struc = ls_dd25
        ib_end   = abap_false.

    CALL METHOD write_table EXPORTING ic_tag = :
      'base-table'     it_table = lt_dd26,
      'lock-parameter' it_table = lt_dd27,
      'lock-argument'  it_table = lt_dden.

    CALL METHOD end_tag.

  ENDMETHOD.                    "process_enqu



  METHOD process_fugr.

    DATA:
      ls_libg  TYPE info_fugrz,
      lt_funcs TYPE TABLE OF rs38l_incl.
    FIELD-SYMBOLS:
      <f>      LIKE LINE OF lt_funcs.

    SELECT SINGLE * FROM info_fugrz
                    INTO ls_libg
                   WHERE area EQ ic_name.                   "#EC *
    CHECK sy-subrc EQ 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'function-group'
        is_struc = ls_libg
        ib_end   = abap_false.
    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = 'RE'.

    CALL FUNCTION 'RS_FUNCTION_POOL_CONTENTS'
      EXPORTING
        function_pool = ls_libg-area
      TABLES
        functab       = lt_funcs
      EXCEPTIONS
        OTHERS        = 0.

    LOOP AT lt_funcs ASSIGNING <f>.
      CALL METHOD process_func
        EXPORTING
          ic_name = <f>-funcname.
    ENDLOOP.


    CALL METHOD end_tag.


  ENDMETHOD.                    "process_fugr



  METHOD process_func.

    DATA:
      ls_func   TYPE v_fdirt,
      lt_docu   TYPE TABLE OF funct,
      lt_exc    TYPE TABLE OF rsexc,
      lt_exp    TYPE TABLE OF rsexp,
      lt_imp    TYPE TABLE OF rsimp,
      lt_cha    TYPE TABLE OF rscha,
      lt_tbl    TYPE TABLE OF rstbl,
      BEGIN OF ls_exc.
    INCLUDE TYPE rsexc.
    DATA:
        description TYPE funct-stext,
      END OF ls_exc,
      BEGIN OF ls_exp.
    INCLUDE TYPE rsexp.
    DATA:
        description TYPE funct-stext,
      END OF ls_exp,
      BEGIN OF ls_imp.
    INCLUDE TYPE rsimp.
    DATA:
        description TYPE funct-stext,
      END OF ls_imp,
      BEGIN OF ls_cha.
    INCLUDE TYPE rscha.
    DATA:
        description TYPE funct-stext,
      END OF ls_cha,
      BEGIN OF ls_tbl.
    INCLUDE TYPE rstbl.
    DATA:
        description TYPE funct-stext,
      END OF ls_tbl.

*   First SELECT statement is with arbitrary language so we make sure
*   we get an entry of the function if there is one. If we would
*   pass MC_LANGU at this point, the SELECT may fail altogether.
    SELECT SINGLE * FROM v_fdirt
                    INTO ls_func
                   WHERE funcname EQ ic_name.               "#EC *
    CHECK sy-subrc EQ 0.
    IF ls_func-spras NE mc_langu.
*     Try to update the language-dependent fields with requested
*     language. If not available, the fields keep the content from the
*     previous SELECT statement.
      SELECT SINGLE spras stext FROM v_fdirt
                    INTO (ls_func-spras, ls_func-stext)
                   WHERE funcname EQ ic_name
                     AND spras    EQ mc_langu.              "#EC *
    ENDIF.

    CALL FUNCTION 'FUNCTION_IMPORT_DOKU'
      EXPORTING
        funcname           = ic_name
        language           = mc_langu
      TABLES
        dokumentation      = lt_docu
        exception_list     = lt_exc
        export_parameter   = lt_exp
        import_parameter   = lt_imp
        changing_parameter = lt_cha
        tables_parameter   = lt_tbl
      EXCEPTIONS
        OTHERS             = 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'function-module'
        is_struc = ls_func
        ib_end   = abap_false.

    CALL METHOD process_parameter
      EXPORTING
        ic_function  = ls_func-funcname
        it_docu      = lt_docu
        :
        it_parameter = lt_imp
        ic_tag       = 'importing'
      CHANGING
        cs_wa        = ls_imp,
        it_parameter = lt_exp
        ic_tag       = 'exporting'
      CHANGING
        cs_wa        = ls_exp,
        it_parameter = lt_cha
        ic_tag       = 'changing'
      CHANGING
        cs_wa        = ls_cha,
        it_parameter = lt_tbl
        ic_tag       = 'tables'
      CHANGING
        cs_wa        = ls_tbl,
        it_parameter = lt_exc
        ic_parmkind  = 'X'
        ic_tag       = 'exception'
      CHANGING
        cs_wa        = ls_exc.


    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = 'FU'
        ic_type  = 'T'.

    CALL METHOD end_tag.


  ENDMETHOD.                    "process_func

  METHOD process_parameter.

    DATA lc_dok TYPE dokhl-object.
    FIELD-SYMBOLS:
      <docu> LIKE LINE OF it_docu,
      <parname> TYPE ANY,
      <desc> TYPE ANY,
      <parm> TYPE ANY.

    LOOP AT it_parameter ASSIGNING <parm>.
      MOVE-CORRESPONDING <parm> TO cs_wa.
      ASSIGN COMPONENT 'DESCRIPTION' OF STRUCTURE cs_wa TO <desc>.
      IF ic_parmkind EQ 'X'.
        ASSIGN COMPONENT 'EXCEPTION' OF STRUCTURE <parm> TO <parname>.
      ELSE.
        ASSIGN COMPONENT 'PARAMETER' OF STRUCTURE <parm> TO <parname>.
      ENDIF.
      READ TABLE it_docu ASSIGNING <docu>
        WITH KEY spras     = mc_langu
                 parameter = <parname>
                 kind      = ic_parmkind
                 version   = '0001'.
      IF sy-subrc EQ 0.
        <desc> = <docu>-stext.
      ELSE.
        CLEAR <desc>.
      ENDIF.

      CALL METHOD write_tag
        EXPORTING
          ic_tag   = ic_tag
          is_struc = cs_wa
          ib_end   = abap_false.
      lc_dok    = ic_function.
      lc_dok+30 = <parname>.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = lc_dok
          ic_dokid = 'FU'
          ic_type  = 'T'.
      CALL METHOD end_tag.

    ENDLOOP.
  ENDMETHOD.                    "process_parameter

  METHOD process_intf.

    DATA:
      ls_clskey     TYPE seoclskey,
      ls_interface  TYPE seoc_interface_r.

    ls_clskey-clsname = ic_name.
    CALL FUNCTION 'SEO_INTERFACE_READ'
      EXPORTING
        intkey          = ls_clskey
        version         = seoc_version_active
        master_language = space
        modif_language  = mc_langu
      IMPORTING
        interface       = ls_interface.
    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'interface'
        is_struc = ls_interface
        ib_end   = abap_false.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = 'IF'.

    CALL METHOD process_object_body
      EXPORTING
        ic_name = ic_name.

    CALL METHOD end_tag. "interface

  ENDMETHOD.                    "process_intf



  METHOD process_tabl.

    DATA:
      lc_name    TYPE ddobjname,
      ls_dd02    TYPE dd02v,
      ls_dd09    TYPE dd09l,
      lt_dd03    TYPE TABLE OF dd03p.
    FIELD-SYMBOLS <dd03> LIKE LINE OF lt_dd03.

    lc_name = ic_name.
    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name                = lc_name
       langu               = mc_langu
     IMPORTING
       dd02v_wa            = ls_dd02
       dd09l_wa            = ls_dd09
     TABLES
       dd03p_tab           = lt_dd03
*     DD05M_TAB           =
*     DD08V_TAB           =
*     DD12V_TAB           =
*     DD17V_TAB           =
*     DD35V_TAB           =
*     DD36M_TAB           =
     EXCEPTIONS
       OTHERS              = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd02 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'table'
        is_struc = ls_dd02
        ib_end   = abap_false.
    IF NOT ls_dd09 IS INITIAL.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'technical-settings'
          is_struc = ls_dd09.
    ENDIF.

    LOOP AT lt_dd03 ASSIGNING <dd03>.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'component'
          is_struc = <dd03>
          ib_end   = abap_false.
*     Especially for customising table it might be valuable to display
*     the data element documentation
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = <dd03>-rollname
          ic_dokid = 'DE'.
      CALL METHOD end_tag.
    ENDLOOP.

    IF p_syscnt         EQ abap_true AND
       ls_dd02-contflag EQ 'S'. "system customising table
      CALL METHOD get_table_content
        EXPORTING
          ic_name = ic_name.
    ENDIF.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = 'TB'.

    CALL METHOD end_tag.

  ENDMETHOD.                    "process_tabl



  METHOD process_ttyp.

    DATA:
      lc_name TYPE ddobjname,
      ls_dd40 TYPE dd40v,
      lt_dd42 TYPE TABLE OF dd42v.

    lc_name = ic_name.
    CALL FUNCTION 'DDIF_TTYP_GET'
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd40v_wa  = ls_dd40
      TABLES
        dd42v_tab = lt_dd42
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd40 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = 'table-type'
        is_struc = ls_dd40
        ib_end   = abap_false.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = 'key'
        it_table = lt_dd42.
    CALL METHOD end_tag.

  ENDMETHOD.                    "process_ttyp



  METHOD process_documentation.

    DATA:
      lt_tline  TYPE tlinetab,
      lc_object TYPE dokhl-object,
      lt_docu   TYPE sotr_texts.
    FIELD-SYMBOLS:
      <t>       LIKE LINE OF lt_tline,
      <d>       LIKE LINE OF lt_docu.

    lc_object = ic_name.
    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = ic_dokid
        langu  = mc_langu
        object = lc_object
        typ    = ic_type
      TABLES
        line   = lt_tline
      EXCEPTIONS
        OTHERS = 0.
    CHECK NOT lt_tline[] IS INITIAL.

* Idea: Use CONVERT_ITF_TO_* here...

    LOOP AT lt_tline ASSIGNING <t>.
      IF sy-tabix     EQ 1 AND
       ( <t>-tdformat EQ space OR <t>-tdformat EQ '=' ).
*       Don't know how the first line of documentation can have such
*       a format, but it happens. So better change the format,
*       otherwise we'll get a short dump 'field symbol not assigned' in
*       the following CASE statement.
        <t>-tdformat = '*'.
      ENDIF.

      CASE <t>-tdformat.
        WHEN space.
          CONCATENATE <d> <t>-tdline INTO <d> SEPARATED BY space.
        WHEN '='.
          CONCATENATE <d> <t>-tdline INTO <d>.
        WHEN OTHERS.
          APPEND INITIAL LINE TO lt_docu ASSIGNING <d>.
          <d> = <t>-tdline.
      ENDCASE.

    ENDLOOP.


    CALL METHOD write_tag
      EXPORTING
        ic_tag = 'documentation'
        ib_end = abap_false.
    LOOP AT lt_docu ASSIGNING <d>.
      REPLACE ALL OCCURRENCES OF '&VLINE&' IN <d> WITH '|'.
      IF <d> CP '&*&'.
        IF get_tag( ) NE 'documentation'. CALL METHOD end_tag. ENDIF.
        SHIFT <d> LEFT DELETING LEADING '&'.
        REPLACE '&' IN <d> WITH space.
        TRANSLATE <d> TO LOWER CASE.                      "#EC SYNTCHAR
        CALL METHOD write_tag
          EXPORTING
            ic_tag = <d>
            ib_end = abap_false.
      ELSE.
        <d> = convert_entities( <d> ).
        APPEND <d> TO mt_output REFERENCE INTO mr_output.
      ENDIF.
    ENDLOOP.
    IF get_tag( ) NE 'documentation'. CALL METHOD end_tag. ENDIF.
    CALL METHOD end_tag.


  ENDMETHOD.                    "process_documentation



  METHOD process_object_body.

    DATA:
      BEGIN OF ls_doku,
        id          TYPE doku_id,
        object      TYPE doku_obj,
      END OF ls_doku,
      lr_descr      TYPE REF TO cl_abap_objectdescr,
      ls_clifkey    TYPE seoclskey,
      lt_clifkey    TYPE TABLE OF seoclskey,
      lt_attrs      TYPE TABLE OF vseoattrib,
      ls_attr       TYPE vseoattrib,
      lt_meth       TYPE TABLE OF vseomethod,
      ls_meth       TYPE vseomethod,
      lt_evt        TYPE TABLE OF vseoevent,
      ls_event      TYPE vseoevent,
      lt_methpar    TYPE TABLE OF vseoparam,
      lt_methexc    TYPE TABLE OF vseoexcep,
      ls_reltype    TYPE seocpdkey,
      ls_cmpkey     TYPE seocmpkey,
      ls_relkey     TYPE seorelkey,
*      ls_class      TYPE seoc_class_r,
      lt_methpar2   TYPE seos_parameters_r,
      lt_methexc2   TYPE seos_exceptions_r,
      ls_attd       TYPE ys_attrdescr,
      ls_mthd       TYPE ys_methdescr,
      ls_pard       TYPE ys_parmdescr,
      ls_excd       TYPE ys_excpdescr,
      ls_evtd       TYPE ys_evntdescr.
    FIELD-SYMBOLS:
      <pr>          LIKE LINE OF ls_mthd-parameters,
      <ex>          LIKE LINE OF ls_mthd-exceptions,
      <par>         LIKE LINE OF lt_methpar,
      <exc>         LIKE LINE OF lt_methexc,
      <evt>         LIKE LINE OF lr_descr->events,
      <att>         LIKE LINE OF lr_descr->attributes,
      <mth>         LIKE LINE OF lr_descr->methods.

    lr_descr ?= cl_abap_typedescr=>describe_by_name( ic_name ).

    CALL METHOD write_table
      EXPORTING
        ic_tag   = 'interface'
        it_table = lr_descr->interfaces.

    ls_clifkey-clsname = ic_name.
    APPEND ls_clifkey TO lt_clifkey.
    CALL FUNCTION 'SEO_COMPONENTS_SELECT'
      EXPORTING
        langu              = mc_langu
      TABLES
        clif_keys          = lt_clifkey
        comp_attributes    = lt_attrs
        comp_methods       = lt_meth
        comp_events        = lt_evt
        subcomp_parameters = lt_methpar
        subcomp_exceptions = lt_methexc
      EXCEPTIONS
        OTHERS             = 0.

    LOOP AT lr_descr->attributes ASSIGNING <att>.

      CLEAR: ls_attr, ls_relkey, ls_cmpkey.
      IF NOT <att>-alias_for IS INITIAL.
*       ...
      ELSEIF <att>-is_inherited  EQ abap_true OR
           ( <att>-is_interface  EQ abap_true AND
             lr_descr->type_kind NE lr_descr->typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = <att>-name.
        CALL FUNCTION 'SEO_COMPONENT_BY_INHERITANCE'
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION 'SEO_ATTRIBUTE_GET'
          EXPORTING
            attkey    = ls_cmpkey
          IMPORTING
            attribute = ls_attr
          EXCEPTIONS
            OTHERS    = 0.
      ELSE.
        READ TABLE lt_attrs INTO ls_attr
          WITH KEY cmpname = <att>-name.                    "#EC *
      ENDIF.

      MOVE-CORRESPONDING <att> TO ls_attd.
      ls_attd-description = ls_attr-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'attribute'
          is_struc = ls_attd
          ib_end   = abap_false.
      IF NOT ls_attr IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = 'att-ddic'
            is_struc = ls_attr.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'inheritance'
              is_struc = ls_relkey.
        ENDIF.
      ENDIF.

      IF <att>-is_interface EQ abap_true.
        ls_doku-id = 'IA'.
      ELSE.
        ls_doku-id = 'CA'.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = <att>-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. "attribute
    ENDLOOP.



    LOOP AT lr_descr->methods ASSIGNING <mth>.
      CLEAR: ls_meth, ls_relkey.
      IF NOT <mth>-alias_for IS INITIAL.
*       ...
      ELSEIF <mth>-is_inherited  EQ abap_true OR
           ( <mth>-is_interface  EQ abap_true AND
             lr_descr->type_kind NE lr_descr->typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = <mth>-name.
        CALL FUNCTION 'SEO_COMPONENT_BY_INHERITANCE'
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION 'SEO_METHOD_SIGNATURE_GET'
          EXPORTING
            mtdkey     = ls_cmpkey
          IMPORTING
            method     = ls_meth
            PARAMETERS = lt_methpar2
            exceps     = lt_methexc2
          EXCEPTIONS
            OTHERS     = 0.
      ELSE.
        READ TABLE lt_meth INTO ls_meth
          WITH KEY cmpname = <mth>-name.                    "#EC *
        REFRESH: lt_methpar2, lt_methexc2.
        LOOP AT lt_methpar ASSIGNING <par>
          WHERE cmpname EQ ls_meth-cmpname.
          APPEND <par> TO lt_methpar2.
        ENDLOOP.
        LOOP AT lt_methexc ASSIGNING <exc>
          WHERE cmpname EQ ls_meth-cmpname.
          APPEND <exc> TO lt_methexc2.
        ENDLOOP.
      ENDIF.

      MOVE-CORRESPONDING <mth> TO ls_mthd.
      ls_mthd-description = ls_meth-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'method'
          is_struc = ls_mthd
          ib_end   = abap_false.
      IF NOT ls_meth IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = 'meth-ddic'
            is_struc = ls_meth.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'inheritance'
              is_struc = ls_relkey.
        ENDIF.

        LOOP AT <mth>-parameters ASSIGNING <pr>.
          READ TABLE lt_methpar2 ASSIGNING <par>
            WITH KEY clsname = ls_meth-clsname
                     cmpname = ls_meth-cmpname
                     sconame = <pr>-name.
          MOVE-CORRESPONDING <pr> TO ls_pard.
          ls_pard-description = <par>-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'parameter'
              is_struc = ls_pard
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'par-ddic'
              is_struc = <par>.
          CALL METHOD end_tag. "method
        ENDLOOP.
        LOOP AT <mth>-exceptions ASSIGNING <ex>.
          READ TABLE lt_methexc2 ASSIGNING <exc>
            WITH KEY clsname = ls_meth-clsname
                     cmpname = ls_meth-cmpname
                     sconame = <ex>-name.
          MOVE-CORRESPONDING <ex> TO ls_excd.
          ls_excd-description = <exc>-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'exception'
              is_struc = ls_excd
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'exc-ddic'
              is_struc = <exc>.
          CALL METHOD end_tag. " exception
        ENDLOOP.
      ENDIF.

      IF <mth>-is_interface EQ abap_true.
        ls_doku-id = 'IO'.
      ELSE.
        ls_doku-id = 'CO'.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = <mth>-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. "method
    ENDLOOP.



    LOOP AT lr_descr->events ASSIGNING <evt>.
      CLEAR: ls_event, ls_relkey, ls_cmpkey.
      IF NOT <evt>-alias_for IS INITIAL.
*       ...
      ELSEIF <evt>-is_inherited  EQ abap_true OR
           ( <evt>-is_interface  EQ abap_true AND
             lr_descr->type_kind NE lr_descr->typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = <evt>-name.
        CALL FUNCTION 'SEO_COMPONENT_BY_INHERITANCE'
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION 'SEO_EVENT_SIGNATURE_GET'
          EXPORTING
            evtkey     = ls_cmpkey
          IMPORTING
            event      = ls_event
            PARAMETERS = lt_methpar2
          EXCEPTIONS
            OTHERS     = 0.
      ELSE.
        READ TABLE lt_evt INTO ls_event
          WITH KEY cmpname = <evt>-name.                    "#EC *
        REFRESH lt_methpar2.
        LOOP AT lt_methpar ASSIGNING <par>
          WHERE cmpname EQ ls_event-cmpname.
          APPEND <par> TO lt_methpar2.
        ENDLOOP.
      ENDIF.
      APPEND INITIAL LINE TO lt_methpar2 ASSIGNING <par>.
      IF NOT ls_cmpkey IS INITIAL.
        MOVE-CORRESPONDING ls_cmpkey TO <par>.
      ELSE.
        MOVE-CORRESPONDING ls_event TO <par>.
      ENDIF.
      <par>-sconame    = 'SENDER'.
      <par>-version    = '1'. "active
      <par>-langu      = mc_langu.
      <par>-descript   = 'Implicitly added sender of the event'(001).
      <par>-cmptype    = '2'. "method
      <par>-mtdtype    = '0'. "regular method
      <par>-editorder  = '0'.
      <par>-dispid     = '0'.
      <par>-author     = ls_event-author.
      <par>-createdon  = ls_event-createdon.
      <par>-changedby  = ls_event-changedby.
      <par>-changedon  = ls_event-changedon.
      <par>-pardecltyp = '1'. "always exporting
      <par>-parpasstyp = '0'. "always by-value
      <par>-typtype    = '3'. "TYPE REF TO
      <par>-type       = ic_name.
*      <par>-TABLEOF
*      <par>-PARVALUE
*      <par>-PAROPTIONL
*      <par>-PARPREFERD
*      <par>-LOCKED

      MOVE-CORRESPONDING <evt> TO ls_evtd.
      ls_evtd-description = ls_event-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'event'
          is_struc = ls_evtd
          ib_end   = abap_false.
      IF NOT ls_event IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = 'evt-ddic'
            is_struc = ls_event.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'inheritance'
              is_struc = ls_relkey.
        ENDIF.

        LOOP AT <evt>-parameters ASSIGNING <pr>.
          READ TABLE lt_methpar2 ASSIGNING <par>
            WITH KEY clsname = ls_event-clsname
                     cmpname = ls_event-cmpname
                     sconame = <pr>-name.
          MOVE-CORRESPONDING <pr> TO ls_pard.
          ls_pard-description = <par>-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'parameter'
              is_struc = ls_pard
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = 'par-ddic'
              is_struc = <par>.
          CALL METHOD end_tag. "method
        ENDLOOP.
      ENDIF.

      IF <evt>-is_interface EQ abap_true.
        ls_doku-id = 'IE'.
      ELSE.
        ls_doku-id = 'CE'.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = <evt>-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. "method
    ENDLOOP.

  ENDMETHOD.                    "process_object_body



  METHOD get_table_content.

    DATA:
      lr_content TYPE REF TO data.
    FIELD-SYMBOLS:
      <content>  TYPE ANY.

    CREATE DATA lr_content TYPE (ic_name).
    ASSIGN lr_content->* TO <content>.
    SELECT * FROM (ic_name) INTO <content>.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = 'entry'
          is_struc = <content>.
    ENDSELECT.

  ENDMETHOD.                    "get_table_content



  METHOD write_table.

    FIELD-SYMBOLS <l> TYPE ANY.

    LOOP AT it_table ASSIGNING <l>.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = ic_tag
          is_struc = <l>.
    ENDLOOP.

  ENDMETHOD.                    "write_table



  METHOD write_tag.

    DATA lc_str TYPE string.


    APPEND INITIAL LINE TO mt_output REFERENCE INTO mr_output.
    INSERT ic_tag INTO mt_tags INDEX 1.

    IF is_struc IS SUPPLIED.
      lc_str = write_attributes( is_struc ).
    ENDIF.

    IF ib_end EQ abap_true.
      CONCATENATE '<' ic_tag lc_str '/>' INTO mr_output->*.
      DELETE mt_tags INDEX 1.
    ELSE.
      CONCATENATE '<' ic_tag lc_str '>' INTO mr_output->*.
    ENDIF.

  ENDMETHOD.                    "write_tag


  METHOD end_tag.

    DATA lc_tag TYPE string.

    APPEND INITIAL LINE TO mt_output REFERENCE INTO mr_output.
    lc_tag = get_tag( ).
    CONCATENATE '</' lc_tag '>' INTO mr_output->*.
    DELETE mt_tags INDEX 1.

  ENDMETHOD.                    "end_tag


  METHOD get_tag.
    READ TABLE mt_tags INTO ec_tag INDEX 1.
  ENDMETHOD .                    "get_tag


*&---------------------------------------------------------------------*
*&      Form  write_attributes
*&---------------------------------------------------------------------*
  METHOD write_attributes.

    DATA:
      lr_descr TYPE REF TO cl_abap_structdescr,
      lc_attr  TYPE string.
    FIELD-SYMBOLS:
      <c>      LIKE LINE OF lr_descr->components,
      <f>      TYPE ANY.

    lr_descr ?= cl_abap_typedescr=>describe_by_data( is_struc ).

    LOOP AT lr_descr->components ASSIGNING <c>.
      CLEAR lc_attr.
      ASSIGN COMPONENT <c>-name OF STRUCTURE is_struc TO <f>.
      lc_attr = write_attribute( ic_name = <c>-name i_field = <f> ).
      CHECK NOT lc_attr IS INITIAL.
      CONCATENATE ec_attr lc_attr INTO ec_attr SEPARATED BY space.
    ENDLOOP.

  ENDMETHOD.                    "write_attributes

*&---------------------------------------------------------------------*
*&      Form  write_attribute
*&---------------------------------------------------------------------*
  METHOD write_attribute.

    DATA:
      lc_name  TYPE string,
      lc_value TYPE string.
*      li_len   TYPE i.

    lc_name = get_attribute_name( ic_name ).
    CHECK NOT lc_name IS INITIAL.
  lc_value = get_attribute_value( ic_name = lc_name i_field = i_field ).
    CHECK NOT lc_value IS INITIAL.
    CONCATENATE lc_name '=' lc_value INTO ec_attribute.

  ENDMETHOD.                    "write_attribute

*&---------------------------------------------------------------------*
*&      Form  write_attribute_name
*&---------------------------------------------------------------------*
  METHOD get_attribute_name.

    IF get_tag( ) NE 'entry'.
      CHECK ic_name NE: 'DDLANGUAGE', 'SPRAS', 'LANGU',
                        'INTLENGTH', 'EDITORDER', 'R3RELEASE', 'DISPID',
                        'UUID'.
    ENDIF.

    transl 'DDTEXT' 'description'.
    transl 'DESCRIPT' 'description'.
    transl 'AS4USER' 'changedby'.
    transl 'AS4DATE' 'changedon'.
    transl 'AS4USER' 'changedby'.


    CASE get_tag( ).
      WHEN 'package' OR 'subpackage'.
        transl 'DEVCLASS' 'name'.
        transl 'CTEXT' 'description'.
      WHEN 'class' OR 'subclass' OR 'superclass'.
        CHECK ic_name NE: 'LANGU', 'REFCLSNAME'.
        transl 'CLSNAME' 'name'.
      WHEN 'attribute'. "of a class
        CHECK ic_name NE: 'LENGTH', 'DECIMALS'.
*        transl 'CMPNAME' 'name'.
*        transl 'ATTDECLTYP' 'scope'.
      WHEN 'method'. "of a class
        CHECK ic_name NE: 'PARAMETERS', 'EXCEPTIONS'.
*        CHECK ic_name NE: 'CLSNAME'.
        transl 'CMPNAME' 'name'.
        transl 'MTDDECLTYP' 'scope'.
      WHEN 'parameter'. "of a function module or class
        CHECK ic_name NE: 'POSITION', 'CLSNAME', 'CMPNAME', 'LENGTH',
                          'DECIMALS'.
        transl 'SCONAME' 'name'.   "class
        transl 'TABNAME' 'type'.
        transl 'PARAMTEXT' 'description'.
      WHEN 'event'.
        CHECK ic_name NE 'PARAMETERS'.
      WHEN 'dataelem'.
        transl 'ROLLNAME' 'name'.
      WHEN 'domain'.
        transl 'DOMNAME' 'name'.
      WHEN 'fixed-value'. "of domain
        CHECK ic_name NE: 'DOMNAME', 'VALPOS'.
      WHEN 'enqueue-object'.
        transl 'VIEWNAME' 'name'.
      WHEN 'base-table'. "of an enqueue object
        CHECK ic_name NE 'VIEWNAME'.
        transl 'TABNAME' 'type'.
      WHEN 'lock-argument'. "of an enqueue object
        CHECK ic_name NE 'VIEWNAME'.
      WHEN 'lock-parameter'. "of an enqueue object
        CHECK ic_name NE 'VIEWNAME'.
      WHEN 'function-group'.
        CHECK ic_name NE 'DEVCLASS'.
        transl 'AREA' 'name'.
        transl 'AREAT' 'description'.
      WHEN 'function-module'.
        CHECK ic_name NE 'AREA'.
        transl 'FUNCNAME' 'name'.
        transl 'STEXT' 'description'.
      WHEN 'importing' OR 'exporting' OR 'changing' OR 'tables'.
        transl 'PARAMETER' 'name'.
        transl 'TYP' 'type'.
        transl 'DBFIELD' 'type'.
        transl 'DBSTRUCT' 'type'.
      WHEN 'exception'.
        transl 'EXCEPTION' 'name'.
      WHEN 'interface'.
        transl 'CLSNAME' 'name'.
      WHEN 'table'.
        transl 'TABNAME' 'name'.
        transl 'ROLLNAME' 'type'.
      WHEN 'component'. "of a table or structure
        CHECK ic_name NE: 'TABNAME', 'POSITION', 'OFFSET'.
        transl 'FIELDNAME' 'name'.
        transl 'ROLLNAME' 'type'.
      WHEN 'table-type'.
        transl 'TYPENAME' 'name'.
        transl 'ROWTYPE' 'type'.
      WHEN 'key'. "of table-type.
        CHECK ic_name NE 'TYPENAME'.

    ENDCASE.

    IF ec_name IS INITIAL. "none of previous translations applied
      ec_name = ic_name.
      TRANSLATE ec_name TO LOWER CASE.
    ENDIF.

  ENDMETHOD.                    "write_attribute_name


*&---------------------------------------------------------------------*
*&      Form  get_attribute_value
*&---------------------------------------------------------------------*
  METHOD get_attribute_value.

    DATA:
      lc(100) TYPE c,
      ls_address TYPE bapiaddr3,
      lt_return TYPE bapiret2_t.

    WRITE i_field TO lc LEFT-JUSTIFIED.

    IF lc IS INITIAL. "initial in character mode, i.e. lc is space

      CHECK get_tag( ) EQ 'fixed-value' OR
            get_tag( ) EQ 'entry'.

      ec_value = '" "'.
      EXIT.

    ELSEIF lc EQ '00.00.0000'.
*     Ignore initial dates
      EXIT.

    ELSEIF ic_name EQ 'author' OR
           ic_name EQ 'changedby'.

      CALL FUNCTION 'BAPI_USER_GET_DETAIL'
        EXPORTING
          username = i_field
        IMPORTING
          address  = ls_address
        TABLES
          return   = lt_return.
      IF NOT ls_address-firstname IS INITIAL OR
         NOT ls_address-lastname IS INITIAL.
        CONCATENATE ls_address-firstname ls_address-lastname INTO lc
          SEPARATED BY space.
        CONDENSE lc.
      ENDIF.

    ENDIF.

    ec_value = convert_entities( lc ).
    CONCATENATE '"' ec_value '"' INTO ec_value.


  ENDMETHOD.                    "get_attribute_value


  METHOD convert_entities.

    ec_value = ic_value.

    REPLACE ALL OCCURRENCES OF:
* the ampersand must be replaced first, otherwise it will also be
* replaced in following entity declarations (e.g. > becomes &amp;gt; ).
      '&'  IN ec_value WITH '&amp;',
      '<'  IN ec_value WITH '&lt;',
      '>'  IN ec_value WITH '&gt;',
      '"'  IN ec_value WITH '&quot;',
      '''' IN ec_value WITH '&apos;',
      '±'  IN ec_value WITH '&#177;',
      '³'  IN ec_value WITH '&#177;',
      '¶'  IN ec_value WITH '&#182;',
      '¼'  IN ec_value WITH '&#188;',
      '¿'  IN ec_value WITH '&#191;',
      'Ä'  IN ec_value WITH '&#196;',
      'Ö'  IN ec_value WITH '&#214;',
      'Ü'  IN ec_value WITH '&#220;',
      'ß'  IN ec_value WITH '&#223;',
      'à'  IN ec_value WITH '&#224;',
      'á'  IN ec_value WITH '&#225;',
      'â'  IN ec_value WITH '&#226;',
      'ã'  IN ec_value WITH '&#227;',
      'ä'  IN ec_value WITH '&#228;',
      'æ'  IN ec_value WITH '&#230;',
      'ç'  IN ec_value WITH '&#231;',
      'è'  IN ec_value WITH '&#233;',
      'é'  IN ec_value WITH '&#234;',
      'ê'  IN ec_value WITH '&#235;',
      'ì'  IN ec_value WITH '&#236;',
      'í'  IN ec_value WITH '&#237;',
      'î'  IN ec_value WITH '&#238;',
      'ñ'  IN ec_value WITH '&#241;',
      'ó'  IN ec_value WITH '&#243;',
      'ô'  IN ec_value WITH '&#244;',
      'õ'  IN ec_value WITH '&#245;',
      'ö'  IN ec_value WITH '&#246;',
      'ù'  IN ec_value WITH '&#249;',
      'ú'  IN ec_value WITH '&#250;',
      'ü'  IN ec_value WITH '&#252;'.


  ENDMETHOD.                    "convert_entities


  METHOD get_superclass .

    CLEAR ec_superclass.

    DATA:
      lr_descr TYPE REF TO cl_abap_typedescr,
      lr_class TYPE REF TO cl_abap_classdescr.

    CALL METHOD cl_abap_typedescr=>describe_by_name
      EXPORTING
        p_name      = ic_classname
      RECEIVING
        p_descr_ref = lr_descr
      EXCEPTIONS
        OTHERS      = 1.
    CHECK sy-subrc EQ 0.

    CATCH SYSTEM-EXCEPTIONS move_cast_error = 1.
      lr_class ?= lr_descr.
    ENDCATCH.
    CHECK sy-subrc EQ 0.

    CALL METHOD lr_class->get_super_class_type
      RECEIVING
        p_descr_ref = lr_descr
      EXCEPTIONS
        OTHERS      = 1.
    CHECK: sy-subrc     EQ 0,
           NOT lr_descr IS INITIAL. "no superclass

    ec_superclass = lr_descr->get_relative_name( ).

  ENDMETHOD.                    "GET_SUPERCLASS

ENDCLASS.                    "ycl_generator IMPLEMENTATION
