<?xml version="1.0" encoding="iso-8859-1"?>
<PROG NAME="ZAPAP" VARCL="X" SUBC="1" CNAM="GERTH" CDAT="20070426" UNAM="GERTH" UDAT="20100409" VERN="000095" RMAND="000" RLOAD="E" FIXPT="X" SDATE="20100409" STIME="114325" IDATE="20100409" ITIME="114325" UCCHECK="X">
 <textPool>
  <language SPRAS="E">
   <textElement ID="I" KEY="REP" ENTRY="Repository objects" LENGTH="20 "/>
   <textElement ID="R" ENTRY="Generate an XML file of repository objects" LENGTH="42 "/>
   <textElement ID="S" KEY="PB_DISPL" ENTRY="        Display XML" LENGTH="19 "/>
   <textElement ID="S" KEY="P_APPL" ENTRY="        Application name" LENGTH="24 "/>
   <textElement ID="S" KEY="P_CLAS" ENTRY="        Class" LENGTH="13 "/>
   <textElement ID="S" KEY="P_DOMA" ENTRY="        Domain" LENGTH="14 "/>
   <textElement ID="S" KEY="P_DTEL" ENTRY="        Data element" LENGTH="20 "/>
   <textElement ID="S" KEY="P_ENQU" ENTRY="        Enqueue object" LENGTH="22 "/>
   <textElement ID="S" KEY="P_FILE" ENTRY="        Download to" LENGTH="19 "/>
   <textElement ID="S" KEY="P_FUGR" ENTRY="        Function group" LENGTH="22 "/>
   <textElement ID="S" KEY="P_INTF" ENTRY="        Interface" LENGTH="17 "/>
   <textElement ID="S" KEY="P_LANGU" ENTRY="        Language" LENGTH="16 "/>
   <textElement ID="S" KEY="P_RECURS" ENTRY="        Recursively select subpackages" LENGTH="38 "/>
   <textElement ID="S" KEY="P_SYSCNT" ENTRY="        Include system table content" LENGTH="36 "/>
   <textElement ID="S" KEY="P_TABL" ENTRY="        Table / structure" LENGTH="25 "/>
   <textElement ID="S" KEY="P_TTYP" ENTRY="        Table type" LENGTH="18 "/>
   <textElement ID="S" KEY="S_DEVCLS" ENTRY="D       Package" LENGTH="15 "/>
  </language>
 </textPool>
 <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZAPAP                                                       *
*&amp;                                                                     *
*&amp;---------------------------------------------------------------------*
*
* APAP - Generate javadoc-style documentation for SAP repository objects
* Copyright (C) 2007  Björn Harmen Gerth
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the
* Free Software Foundation, Inc.
* 51 Franklin Street
* Fifth Floor
* Boston, MA 02110-1301
* USA
*&amp;---------------------------------------------------------------------*

REPORT zapap NO STANDARD PAGE HEADING LINE-SIZE 255.

DEFINE transl.
  if ic_name = &amp;1.
    check &amp;2 &lt;&gt; space.
    ec_name = &amp;2.
  endif.
END-OF-DEFINITION.

TYPES:
  BEGIN OF ys_selopt,
    sign   TYPE bapisign,
    option TYPE bapioption,
    low    TYPE tadir-object,
    high   TYPE tadir-object,
  END OF ys_selopt,
  yl_selopt TYPE TABLE OF ys_selopt,
  yl_devc   TYPE TABLE OF tdevc-devclass.

*----------------------------------------------------------------------*
*       CLASS ycl_generator DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ycl_generator DEFINITION.

  PUBLIC SECTION.
    TYPE-POOLS:
      abap,
      seoc,
      seor,
      seos.

    DATA:
      mc_langu    TYPE sy-langu,
      mt_selopt   TYPE yl_selopt,
      mt_packages TYPE yl_devc,
      mb_recurse  TYPE abap_bool,
      mt_stack    TYPE STANDARD TABLE OF REF TO if_ixml_element,
      mr_current  TYPE REF TO if_ixml_element,
      mr_xml_doc  TYPE REF TO if_ixml_document.

    METHODS:
      constructor
        IMPORTING
          ic_langu   TYPE sy-langu
          it_selopt  TYPE yl_selopt OPTIONAL
          ib_recurse TYPE abap_bool DEFAULT abap_false
          ic_appname TYPE csequence,
     process_packages
       IMPORTING it_packages TYPE yl_devc,
     process_clas
       IMPORTING ic_name TYPE c,
     process_devc
       IMPORTING ic_name TYPE c,
     process_dtel
       IMPORTING ic_name TYPE c,
     process_doma
       IMPORTING ic_name TYPE c,
     process_fugr
       IMPORTING ic_name TYPE c,
     process_func
       IMPORTING ic_name TYPE c,
     process_enqu
       IMPORTING ic_name TYPE c,
     process_intf
       IMPORTING ic_name TYPE c,
     process_tabl
       IMPORTING ic_name TYPE c,
     process_ttyp
       IMPORTING ic_name TYPE c.

  PROTECTED SECTION.
    TYPES BEGIN OF ys_attrdescr.
    INCLUDE TYPE abap_attrdescr.
    TYPES description TYPE string.
    TYPES END OF ys_attrdescr.
    TYPES BEGIN OF ys_methdescr.
    INCLUDE TYPE abap_methdescr.
    TYPES description TYPE string.
    TYPES END OF ys_methdescr.
    TYPES BEGIN OF ys_parmdescr.
    INCLUDE TYPE abap_parmdescr.
    TYPES description TYPE string.
    TYPES END OF ys_parmdescr.
    TYPES BEGIN OF ys_excpdescr.
    INCLUDE TYPE abap_excpdescr.
    TYPES description TYPE string.
    TYPES END OF ys_excpdescr.
    TYPES BEGIN OF ys_evntdescr.
    INCLUDE TYPE abap_evntdescr.
    TYPES description TYPE string.
    TYPES END OF ys_evntdescr.

    METHODS:
      process_object_body
        IMPORTING ic_name  TYPE c,
      process_parameter
        IMPORTING
          ic_function  TYPE c
          ic_tag       TYPE string
          it_docu      TYPE rsfb_fdo
          it_parameter TYPE STANDARD TABLE
          ic_parmkind  TYPE funct-kind DEFAULT &apos;P&apos;
        CHANGING
          cs_wa        TYPE any,
      process_documentation
        IMPORTING
          ic_name  TYPE c
          ic_dokid TYPE c
          ic_type  TYPE dokhl-typ DEFAULT &apos;E&apos;,
      get_attribute_value
        IMPORTING
          ic_name  TYPE any
          i_field  TYPE any
        RETURNING
          value(ec_value) TYPE string,
      get_attribute_name
        IMPORTING ic_name TYPE c
        RETURNING value(ec_name) TYPE string,
      write_attribute
        IMPORTING ic_name TYPE c i_field TYPE any
        RETURNING value(ec_attribute) TYPE string,
      write_attributes
        IMPORTING is_struc TYPE any,
      end_tag,
      write_tag
        IMPORTING
          ic_tag   TYPE string
          is_struc TYPE any OPTIONAL
          ib_end   TYPE abap_bool DEFAULT abap_true,
      write_table
        IMPORTING
          ic_tag   TYPE string
          it_table TYPE ANY TABLE,
      get_table_content
        IMPORTING ic_name TYPE c,
      get_superclass
        IMPORTING ic_classname TYPE any
        RETURNING value(ec_superclass) TYPE seoclsname,
      check_class_syntax
        IMPORTING is_class TYPE seoclskey
        RETURNING value(eb_check_succeeded) TYPE abap_bool.
ENDCLASS.                    &quot;ycl_generator DEFINITION

DATA gc_devc   TYPE tdevc-devclass.
PARAMETERS:
* text: &apos;Application name&apos;
  p_appl       TYPE cvers_ref-desc_text.
SELECT-OPTIONS:
* text from ddic
  s_devcls     FOR gc_devc OBLIGATORY.
PARAMETERS:
* text: &apos;Recursively select subpackages&apos;
  p_recurs     TYPE abap_bool AS CHECKBOX,
* text: &apos;Language&apos;
  p_langu      TYPE sy-langu  DEFAULT sy-langu,
* text: &apos;Download to&apos;
  p_file       TYPE rlgrap-filename,
* text: &apos;Display XML&apos;
  pb_displ     TYPE abap_bool AS CHECKBOX.

* Add all supported repository objects here
SELECTION-SCREEN BEGIN OF BLOCK bl1 WITH FRAME TITLE text-rep.
PARAMETERS:
* text: &apos;Table / structure&apos;
  p_tabl   TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN BEGIN OF BLOCK bl2 WITH FRAME.
PARAMETERS:
* text: &apos;Include system table content&apos;
  p_syscnt TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN END OF BLOCK bl2.
PARAMETERS:
* text: &apos;Table type&apos;
  p_ttyp   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Data element&apos;
  p_dtel   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Domain&apos;
  p_doma   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Enqueue object&apos;
  p_enqu   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Class&apos;
  p_clas   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Interface&apos;
  p_intf   TYPE abap_bool AS CHECKBOX DEFAULT abap_true,
* text: &apos;Function group&apos;
  p_fugr   TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECTION-SCREEN END OF BLOCK bl1.

DATA:
  gr_generator TYPE REF TO ycl_generator,
  gt_selopt    TYPE TABLE OF ys_selopt,
  gs_selopt    LIKE LINE OF gt_selopt,
  gt_packages  TYPE yl_devc,
  gc_file      TYPE string,
  gc_path      TYPE string,
  gc_fullpath  TYPE string,
  gi_action    TYPE i.



*-----------------------------------------------------------------------
* Display a file picker window
*-----------------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_file.

  CALL METHOD cl_gui_frontend_services=&gt;file_save_dialog
    EXPORTING
*      WINDOW_TITLE         =
       default_extension    = &apos;xml&apos;
*      DEFAULT_FILE_NAME    =
       file_filter          = &apos;*.xml&apos;
*      INITIAL_DIRECTORY    =
*      WITH_ENCODING        =
*      PROMPT_ON_OVERWRITE  = &apos;X&apos;
    CHANGING
      filename             = gc_file
      path                 = gc_path
      fullpath             = gc_fullpath
      user_action          = gi_action
    EXCEPTIONS
      OTHERS               = 1.
  IF sy-subrc &lt;&gt; 0.
    WRITE: / &apos;An error has occured picking a file&apos;.
    EXIT.
  ENDIF.

  IF gi_action = cl_gui_frontend_services=&gt;action_ok.
    p_file = gc_fullpath.
  ENDIF.



START-OF-SELECTION.

* Add all supported repository objects here
  PERFORM add_selopt USING:
    p_tabl &apos;TABL&apos;,
    p_ttyp &apos;TTYP&apos;,
    p_dtel &apos;DTEL&apos;,
    p_doma &apos;DOMA&apos;,
    p_enqu &apos;ENQU&apos;,
    p_clas &apos;CLAS&apos;,
    p_intf &apos;INTF&apos;,
    p_fugr &apos;FUGR&apos;.
  IF gt_selopt IS INITIAL.
*   Add a dummy select option. Otherwise the table is empty, which would
*   result in the selection of ALL possible repository objects.
    PERFORM add_selopt USING abap_true space.
  ENDIF.


  CREATE OBJECT gr_generator EXPORTING ic_langu   = p_langu
                                       it_selopt  = gt_selopt
                                       ib_recurse = p_recurs
                                       ic_appname = p_appl.

  SELECT devclass FROM tdevc
            INTO TABLE gt_packages
                 WHERE devclass IN s_devcls.
  CALL METHOD gr_generator-&gt;process_packages( gt_packages ).

  PERFORM display_and_download.


*&amp;---------------------------------------------------------------------*
*&amp;      Form  add_selopt
*&amp;---------------------------------------------------------------------*
FORM add_selopt
  USING
    ib_add         TYPE abap_bool
    ic_object_type TYPE tadir-object.

  CHECK ib_add = abap_true.

  gs_selopt-sign   = &apos;I&apos;.
  gs_selopt-option = &apos;EQ&apos;.
  gs_selopt-low    = ic_object_type.
  APPEND gs_selopt TO gt_selopt.

ENDFORM.                    &quot;add_selopt

*&amp;---------------------------------------------------------------------*
*&amp;      Form  display_and_download
*&amp;---------------------------------------------------------------------*
FORM display_and_download.

  DATA: lr_xml_doc TYPE REF TO cl_xml_document,
        lr_node    TYPE REF TO if_ixml_node.

  lr_node = gr_generator-&gt;mr_xml_doc-&gt;get_root( ).
* The first node is the descriptor so we need to get the second
  lr_node = lr_node-&gt;get_first_child( ).

  CREATE OBJECT lr_xml_doc.
  CALL METHOD lr_xml_doc-&gt;create_with_node( node = lr_node ).
  CALL METHOD lr_xml_doc-&gt;set_encoding( &apos;UTF-8&apos; ).


  IF NOT p_file IS INITIAL.
    CALL METHOD lr_xml_doc-&gt;export_to_file( filename = p_file ).
  ENDIF.

  IF pb_displ = abap_true.
    CALL METHOD lr_xml_doc-&gt;display( ).
  ENDIF.

ENDFORM.                    &quot;display_and_download


*----------------------------------------------------------------------*
*       CLASS ycl_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS ycl_generator IMPLEMENTATION.

  METHOD constructor.

    DATA: lr_processor TYPE REF TO if_ixml,
          ls_selopt    LIKE LINE OF mt_selopt,
          lc_date(10)  TYPE c,
          lc_str       TYPE string.

    mc_langu     = ic_langu.
    mt_selopt    = it_selopt.
    mb_recurse   = ib_recurse.
    lr_processor = cl_ixml=&gt;create( ).
    mr_xml_doc   = lr_processor-&gt;create_document( ).
    mr_current = mr_xml_doc-&gt;create_simple_element(
      name = &apos;application&apos; parent = mr_xml_doc ).
    INSERT mr_current INTO mt_stack INDEX 1.

    lc_str = ic_appname.
    CALL METHOD mr_current-&gt;set_attribute( name = &apos;name&apos;
      value = lc_str ).
    WRITE sy-datlo TO lc_date.
    lc_str = lc_date.
    CALL METHOD mr_current-&gt;set_attribute( name = &apos;extraction-date&apos;
      value = lc_str ).


*   The TADIR entry of a package XY contains itself as development class
*   =&gt; endless loop, so exclude package from selection
    ls_selopt-sign   = &apos;E&apos;.
    ls_selopt-option = &apos;EQ&apos;.
    ls_selopt-low    = &apos;DEVC&apos;.
    INSERT ls_selopt INTO mt_selopt INDEX 1.

  ENDMETHOD.                    &quot;constructor

  METHOD process_packages.

    FIELD-SYMBOLS &lt;p&gt; LIKE LINE OF mt_packages.

    mt_packages = it_packages.
    LOOP AT mt_packages ASSIGNING &lt;p&gt;.
      CALL METHOD process_devc( &lt;p&gt; ).
    ENDLOOP.

  ENDMETHOD.                    &quot;process_packages

  METHOD process_clas.

    DATA:
      BEGIN OF ls_spr,
        clsname     TYPE seoclskey-clsname,
*       This will be useful for sorting the superclass by distance
*       to the actual class
        dist        TYPE sy-index,
      END OF ls_spr,
      ls_clskey     TYPE seoclskey,
      ls_class      TYPE seoc_class_r,
      lt_subclasses TYPE seor_inheritance_keys.

    ls_clskey-clsname = ic_name.
    CHECK check_class_syntax( ls_clskey ) = abap_true.

    CALL FUNCTION &apos;SEO_CLASS_READ&apos;
      EXPORTING
        clskey          = ls_clskey
        version         = seoc_version_active
        master_language = space
        modif_language  = mc_langu
      IMPORTING
        class           = ls_class.
    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;class&apos;
        is_struc = ls_class
        ib_end   = abap_false.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;CL&apos;.

    ls_spr-clsname = ic_name.
    DO.
      ls_spr-dist = sy-index.
      ls_spr-clsname = get_superclass( ls_spr-clsname ).
      IF ls_spr-clsname IS INITIAL. EXIT. ENDIF.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;superclass&apos;
          is_struc = ls_spr.
    ENDDO.

    CALL FUNCTION &apos;SEO_CLASS_GET_ALL_SUBS&apos;
      EXPORTING
        clskey  = ls_clskey
      IMPORTING
        inhkeys = lt_subclasses
      EXCEPTIONS
        OTHERS  = 0.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;subclass&apos;
        it_table = lt_subclasses.

    CALL METHOD process_object_body
      EXPORTING
        ic_name = ic_name.

    CALL METHOD end_tag. &quot;class

  ENDMETHOD.                    &quot;process_clas




  METHOD process_devc.

    DATA:
      ls_tadir    TYPE tadir,
      ls_tdevc    TYPE tdevc,
      lc_devclass TYPE tdevc-devclass.
    FIELD-SYMBOLS &lt;lb_deleted&gt; TYPE c.


    CALL FUNCTION &apos;TR_DEVCLASS_GET&apos;
      EXPORTING
        iv_devclass = ic_name
        iv_langu    = mc_langu
      IMPORTING
        es_tdevc    = ls_tdevc
      EXCEPTIONS
        OTHERS      = 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;package&apos;
        is_struc = ls_tdevc
        ib_end   = abap_false.


*   list all subpackages with descriptions
    SELECT devclass FROM tdevc
                    INTO lc_devclass
                   WHERE parentcl EQ ic_name.
      CALL FUNCTION &apos;TR_DEVCLASS_GET&apos;
        EXPORTING
          iv_devclass = lc_devclass
          iv_langu    = mc_langu
        IMPORTING
          es_tdevc    = ls_tdevc
        EXCEPTIONS
          OTHERS      = 0.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;subpackage&apos;
          is_struc = ls_tdevc.

*     If recursion is enabled, append subpackages to package list if
*     not yet included
      IF mb_recurse EQ abap_true.
        COLLECT lc_devclass INTO mt_packages.
      ENDIF.
    ENDSELECT.

*   Process all contained repository objects
    SELECT * FROM tadir
             INTO ls_tadir
            WHERE object   IN mt_selopt
              AND devclass EQ ic_name.

*     Seems field TADIR-DELFLAG was introduced with SAP 6.0
      ASSIGN COMPONENT &apos;DELFLAG&apos; OF STRUCTURE ls_tadir TO &lt;lb_deleted&gt;.
      CHECK sy-subrc &lt;&gt; 0 OR &lt;lb_deleted&gt; = abap_false.

      CASE ls_tadir-object.
        WHEN &apos;CLAS&apos;.
          CALL METHOD process_clas
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;DOMA&apos;.
          CALL METHOD process_doma
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;DTEL&apos;.
          CALL METHOD process_dtel
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;ENQU&apos;.
          CALL METHOD process_enqu
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;FUGR&apos;.
          CALL METHOD process_fugr
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;INTF&apos;.
          CALL METHOD process_intf
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;TABL&apos;.
          CALL METHOD process_tabl
            EXPORTING
              ic_name = ls_tadir-obj_name.
        WHEN &apos;TTYP&apos;.
          CALL METHOD process_ttyp
            EXPORTING
              ic_name = ls_tadir-obj_name.
      ENDCASE.
    ENDSELECT.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_package


  METHOD process_doma.

    DATA:
      lc_name TYPE ddobjname,
      ls_dd01 TYPE dd01v,
      lt_dd07 TYPE TABLE OF dd07v.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_DOMA_GET&apos;
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd01v_wa  = ls_dd01
      TABLES
        dd07v_tab = lt_dd07
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd01 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;domain&apos;
        is_struc = ls_dd01
        ib_end   = abap_false.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;fixed-value&apos;
        it_table = lt_dd07.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;DO&apos;
        ic_type  = &apos;T&apos;.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_domain


  METHOD process_dtel.

    DATA:
      lc_name TYPE ddobjname,
      ls_dd04 TYPE dd04v.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
      EXPORTING
        name                = lc_name
       langu               = mc_langu
     IMPORTING
       dd04v_wa            = ls_dd04
*     TPARA_WA            =
     EXCEPTIONS
       OTHERS              = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd04 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;dataelem&apos;
        is_struc = ls_dd04
        ib_end   = abap_false.
    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;DE&apos;.
    CALL METHOD end_tag.


  ENDMETHOD.                    &quot;process_dataelem


  METHOD process_enqu.

    DATA:
      lc_name    TYPE ddobjname,
      ls_dd25    TYPE dd25v,
      lt_dd26    TYPE TABLE OF dd26e,
      lt_dd27    TYPE TABLE OF dd27p,
      lt_dden    TYPE TABLE OF ddena.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_ENQU_GET&apos;
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd25v_wa  = ls_dd25
      TABLES
        dd26e_tab = lt_dd26
        dd27p_tab = lt_dd27
        ddena_tab = lt_dden
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd25 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;enqueue-object&apos;
        is_struc = ls_dd25
        ib_end   = abap_false.

    CALL METHOD write_table EXPORTING ic_tag = :
      &apos;base-table&apos;     it_table = lt_dd26,
      &apos;lock-parameter&apos; it_table = lt_dd27,
      &apos;lock-argument&apos;  it_table = lt_dden.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_enqu



  METHOD process_fugr.

    DATA:
      ls_libg  TYPE info_fugrz,
      lt_funcs TYPE TABLE OF rs38l_incl.
    FIELD-SYMBOLS:
      &lt;f&gt;      LIKE LINE OF lt_funcs.

    SELECT SINGLE * FROM info_fugrz
                    INTO ls_libg
                   WHERE area EQ ic_name.                   &quot;#EC *
    CHECK sy-subrc EQ 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;function-group&apos;
        is_struc = ls_libg
        ib_end   = abap_false.
    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;RE&apos;.

    CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
      EXPORTING
        function_pool = ls_libg-area
      TABLES
        functab       = lt_funcs
      EXCEPTIONS
        OTHERS        = 0.

    LOOP AT lt_funcs ASSIGNING &lt;f&gt;.
      CALL METHOD process_func
        EXPORTING
          ic_name = &lt;f&gt;-funcname.
    ENDLOOP.


    CALL METHOD end_tag.


  ENDMETHOD.                    &quot;process_fugr



  METHOD process_func.

    DATA:
      ls_func   TYPE v_fdirt,
      lt_docu   TYPE TABLE OF funct,
      lt_exc    TYPE TABLE OF rsexc,
      lt_exp    TYPE TABLE OF rsexp,
      lt_imp    TYPE TABLE OF rsimp,
      lt_cha    TYPE TABLE OF rscha,
      lt_tbl    TYPE TABLE OF rstbl,
      BEGIN OF ls_exc.
    INCLUDE TYPE rsexc.
    DATA:
        description TYPE funct-stext,
      END OF ls_exc,
      BEGIN OF ls_exp.
    INCLUDE TYPE rsexp.
    DATA:
        description TYPE funct-stext,
      END OF ls_exp,
      BEGIN OF ls_imp.
    INCLUDE TYPE rsimp.
    DATA:
        description TYPE funct-stext,
      END OF ls_imp,
      BEGIN OF ls_cha.
    INCLUDE TYPE rscha.
    DATA:
        description TYPE funct-stext,
      END OF ls_cha,
      BEGIN OF ls_tbl.
    INCLUDE TYPE rstbl.
    DATA:
        description TYPE funct-stext,
      END OF ls_tbl.

*   First SELECT statement is with arbitrary language so we make sure
*   we get an entry of the function if there is one. If we would
*   pass MC_LANGU at this point, the SELECT may fail altogether.
    SELECT SINGLE * FROM v_fdirt
                    INTO ls_func
                   WHERE funcname EQ ic_name.               &quot;#EC *
    CHECK sy-subrc EQ 0.
    IF ls_func-spras NE mc_langu.
*     Try to update the language-dependent fields with requested
*     language. If not available, the fields keep the content from the
*     previous SELECT statement.
      SELECT SINGLE spras stext FROM v_fdirt
                    INTO (ls_func-spras, ls_func-stext)
                   WHERE funcname EQ ic_name
                     AND spras    EQ mc_langu.              &quot;#EC *
    ENDIF.

    CALL FUNCTION &apos;FUNCTION_IMPORT_DOKU&apos;
      EXPORTING
        funcname           = ic_name
        language           = mc_langu
      TABLES
        dokumentation      = lt_docu
        exception_list     = lt_exc
        export_parameter   = lt_exp
        import_parameter   = lt_imp
        changing_parameter = lt_cha
        tables_parameter   = lt_tbl
      EXCEPTIONS
        OTHERS             = 0.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;function-module&apos;
        is_struc = ls_func
        ib_end   = abap_false.

    CALL METHOD process_parameter
      EXPORTING
        ic_function  = ls_func-funcname
        it_docu      = lt_docu
        :
        it_parameter = lt_imp
        ic_tag       = &apos;importing&apos;
      CHANGING
        cs_wa        = ls_imp,
        it_parameter = lt_exp
        ic_tag       = &apos;exporting&apos;
      CHANGING
        cs_wa        = ls_exp,
        it_parameter = lt_cha
        ic_tag       = &apos;changing&apos;
      CHANGING
        cs_wa        = ls_cha,
        it_parameter = lt_tbl
        ic_tag       = &apos;tables&apos;
      CHANGING
        cs_wa        = ls_tbl,
        it_parameter = lt_exc
        ic_parmkind  = &apos;X&apos;
        ic_tag       = &apos;exception&apos;
      CHANGING
        cs_wa        = ls_exc.


    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;FU&apos;
        ic_type  = &apos;T&apos;.

    CALL METHOD end_tag.


  ENDMETHOD.                    &quot;process_func

  METHOD process_parameter.

    DATA lc_dok TYPE dokhl-object.
    FIELD-SYMBOLS:
      &lt;docu&gt; LIKE LINE OF it_docu,
      &lt;parname&gt; TYPE ANY,
      &lt;desc&gt; TYPE ANY,
      &lt;parm&gt; TYPE ANY.

    LOOP AT it_parameter ASSIGNING &lt;parm&gt;.
      MOVE-CORRESPONDING &lt;parm&gt; TO cs_wa.
      ASSIGN COMPONENT &apos;DESCRIPTION&apos; OF STRUCTURE cs_wa TO &lt;desc&gt;.
      IF ic_parmkind EQ &apos;X&apos;.
        ASSIGN COMPONENT &apos;EXCEPTION&apos; OF STRUCTURE &lt;parm&gt; TO &lt;parname&gt;.
      ELSE.
        ASSIGN COMPONENT &apos;PARAMETER&apos; OF STRUCTURE &lt;parm&gt; TO &lt;parname&gt;.
      ENDIF.
      READ TABLE it_docu ASSIGNING &lt;docu&gt;
        WITH KEY spras     = mc_langu
                 parameter = &lt;parname&gt;
                 kind      = ic_parmkind
                 version   = &apos;0001&apos;.
      IF sy-subrc EQ 0.
        &lt;desc&gt; = &lt;docu&gt;-stext.
      ELSE.
        CLEAR &lt;desc&gt;.
      ENDIF.

      CALL METHOD write_tag
        EXPORTING
          ic_tag   = ic_tag
          is_struc = cs_wa
          ib_end   = abap_false.
      lc_dok    = ic_function.
      lc_dok+30 = &lt;parname&gt;.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = lc_dok
          ic_dokid = &apos;FU&apos;
          ic_type  = &apos;T&apos;.
      CALL METHOD end_tag.

    ENDLOOP.
  ENDMETHOD.                    &quot;process_parameter

  METHOD process_intf.

    DATA:
      ls_clskey     TYPE seoclskey,
      ls_interface  TYPE seoc_interface_r.

    ls_clskey-clsname = ic_name.
    CALL FUNCTION &apos;SEO_INTERFACE_READ&apos;
      EXPORTING
        intkey          = ls_clskey
        version         = seoc_version_active
        master_language = space
        modif_language  = mc_langu
      IMPORTING
        interface       = ls_interface.
    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;interface&apos;
        is_struc = ls_interface
        ib_end   = abap_false.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;IF&apos;.

    CALL METHOD process_object_body
      EXPORTING
        ic_name = ic_name.

    CALL METHOD end_tag. &quot;interface

  ENDMETHOD.                    &quot;process_intf



  METHOD process_tabl.

    DATA:
      lc_name    TYPE ddobjname,
      ls_dd02    TYPE dd02v,
      ls_dd09    TYPE dd09l,
      lt_dd03    TYPE TABLE OF dd03p.
    FIELD-SYMBOLS &lt;dd03&gt; LIKE LINE OF lt_dd03.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_TABL_GET&apos;
      EXPORTING
        name                = lc_name
       langu               = mc_langu
     IMPORTING
       dd02v_wa            = ls_dd02
       dd09l_wa            = ls_dd09
     TABLES
       dd03p_tab           = lt_dd03
*     DD05M_TAB           =
*     DD08V_TAB           =
*     DD12V_TAB           =
*     DD17V_TAB           =
*     DD35V_TAB           =
*     DD36M_TAB           =
     EXCEPTIONS
       OTHERS              = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd02 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;table&apos;
        is_struc = ls_dd02
        ib_end   = abap_false.
    IF NOT ls_dd09 IS INITIAL.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;technical-settings&apos;
          is_struc = ls_dd09.
    ENDIF.

    LOOP AT lt_dd03 ASSIGNING &lt;dd03&gt;.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;component&apos;
          is_struc = &lt;dd03&gt;
          ib_end   = abap_false.
*     Especially for customising table it might be valuable to display
*     the data element documentation
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = &lt;dd03&gt;-rollname
          ic_dokid = &apos;DE&apos;.
      CALL METHOD end_tag.
    ENDLOOP.

    IF p_syscnt         EQ abap_true AND
       ls_dd02-contflag EQ &apos;S&apos;. &quot;system customising table
      CALL METHOD get_table_content
        EXPORTING
          ic_name = ic_name.
    ENDIF.

    CALL METHOD process_documentation
      EXPORTING
        ic_name  = ic_name
        ic_dokid = &apos;TB&apos;.

    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_tabl



  METHOD process_ttyp.

    DATA:
      lc_name TYPE ddobjname,
      ls_dd40 TYPE dd40v,
      lt_dd42 TYPE TABLE OF dd42v.

    lc_name = ic_name.
    CALL FUNCTION &apos;DDIF_TTYP_GET&apos;
      EXPORTING
        name      = lc_name
        langu     = mc_langu
      IMPORTING
        dd40v_wa  = ls_dd40
      TABLES
        dd42v_tab = lt_dd42
      EXCEPTIONS
        OTHERS    = 1.
    CHECK: sy-subrc EQ 0,
           NOT ls_dd40 IS INITIAL.

    CALL METHOD write_tag
      EXPORTING
        ic_tag   = &apos;table-type&apos;
        is_struc = ls_dd40
        ib_end   = abap_false.
    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;key&apos;
        it_table = lt_dd42.
    CALL METHOD end_tag.

  ENDMETHOD.                    &quot;process_ttyp



  METHOD process_documentation.

    DATA:
      lt_tline       TYPE tlinetab,
      lc_object      TYPE dokhl-object,
      lt_html        TYPE htmltable,
      ls_html        LIKE LINE OF lt_html,
      ls_doku_header TYPE thead,
      lc_docu        TYPE string.

    lc_object = ic_name.
    CALL FUNCTION &apos;DOCU_GET&apos;
      EXPORTING
        id     = ic_dokid
        langu  = mc_langu
        object = lc_object
        typ    = ic_type
      IMPORTING
        head   = ls_doku_header
      TABLES
        line   = lt_tline
      EXCEPTIONS
        OTHERS = 0.
    CHECK NOT lt_tline[] IS INITIAL.

    CALL FUNCTION &apos;CONVERT_ITF_TO_HTML&apos;
      EXPORTING
        i_header      = ls_doku_header
        i_replace     = abap_true
        i_html_header = abap_false
      TABLES
        t_itf_text    = lt_tline
        t_html_text   = lt_html
      EXCEPTIONS
        OTHERS        = 1.
    CHECK sy-subrc = 0.


    LOOP AT lt_html INTO ls_html.
      CONCATENATE lc_docu ls_html-tdline INTO lc_docu.
    ENDLOOP.

    write_tag( ic_tag = &apos;documentation&apos; ib_end = abap_false ).

    mr_current-&gt;set_value( value = lc_docu ).

    end_tag( ).


  ENDMETHOD.                    &quot;process_documentation



  METHOD process_object_body.

    DATA:
      BEGIN OF ls_doku,
        id          TYPE doku_id,
        object      TYPE doku_obj,
      END OF ls_doku,
      lr_desc       TYPE REF TO cl_abap_typedescr,
      lr_descr      TYPE REF TO cl_abap_objectdescr,
      ls_clifkey    TYPE seoclskey,
      lt_clifkey    TYPE TABLE OF seoclskey,
      lt_attrs      TYPE TABLE OF vseoattrib,
      ls_attr       TYPE vseoattrib,
      lt_meth       TYPE TABLE OF vseomethod,
      ls_meth       TYPE vseomethod,
      lt_evt        TYPE TABLE OF vseoevent,
      ls_event      TYPE vseoevent,
      lt_methpar    TYPE TABLE OF vseoparam,
      lt_methexc    TYPE TABLE OF vseoexcep,
      ls_reltype    TYPE seocpdkey,
      ls_cmpkey     TYPE seocmpkey,
      ls_relkey     TYPE seorelkey,
      lt_methpar2   TYPE seos_parameters_r,
      lt_methexc2   TYPE seos_exceptions_r,
      ls_attd       TYPE ys_attrdescr,
      ls_mthd       TYPE ys_methdescr,
      ls_pard       TYPE ys_parmdescr,
      ls_excd       TYPE ys_excpdescr,
      ls_evtd       TYPE ys_evntdescr.
    FIELD-SYMBOLS:
      &lt;pr&gt;          LIKE LINE OF ls_mthd-parameters,
      &lt;ex&gt;          LIKE LINE OF ls_mthd-exceptions,
      &lt;par&gt;         LIKE LINE OF lt_methpar,
      &lt;exc&gt;         LIKE LINE OF lt_methexc,
      &lt;evt&gt;         LIKE LINE OF lr_descr-&gt;events,
      &lt;att&gt;         LIKE LINE OF lr_descr-&gt;attributes,
      &lt;mth&gt;         LIKE LINE OF lr_descr-&gt;methods.

*   If a repository object has been deleted and the request has not
*   been released yet, the TADIR entry still exists. Therefore we
*   are ignoring the exception here
    CALL METHOD cl_abap_typedescr=&gt;describe_by_name
      EXPORTING
        p_name      = ic_name
      RECEIVING
        p_descr_ref = lr_desc
      EXCEPTIONS
        OTHERS      = 1.
    CHECK sy-subrc = 0.
    lr_descr ?= lr_desc.

    CALL METHOD write_table
      EXPORTING
        ic_tag   = &apos;interface&apos;
        it_table = lr_descr-&gt;interfaces.

    ls_clifkey-clsname = ic_name.
    APPEND ls_clifkey TO lt_clifkey.
    CALL FUNCTION &apos;SEO_COMPONENTS_SELECT&apos;
      EXPORTING
        langu              = mc_langu
      TABLES
        clif_keys          = lt_clifkey
        comp_attributes    = lt_attrs
        comp_methods       = lt_meth
        comp_events        = lt_evt
        subcomp_parameters = lt_methpar
        subcomp_exceptions = lt_methexc
      EXCEPTIONS
        OTHERS             = 0.

    LOOP AT lr_descr-&gt;attributes ASSIGNING &lt;att&gt;.

      CLEAR: ls_attr, ls_relkey, ls_cmpkey.
      IF NOT &lt;att&gt;-alias_for IS INITIAL.
*       ...
      ELSEIF &lt;att&gt;-is_inherited  EQ abap_true OR
           ( &lt;att&gt;-is_interface  EQ abap_true AND
             lr_descr-&gt;type_kind NE lr_descr-&gt;typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = &lt;att&gt;-name.
        CALL FUNCTION &apos;SEO_COMPONENT_BY_INHERITANCE&apos;
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION &apos;SEO_ATTRIBUTE_GET&apos;
          EXPORTING
            attkey    = ls_cmpkey
          IMPORTING
            attribute = ls_attr
          EXCEPTIONS
            OTHERS    = 0.
      ELSE.
        READ TABLE lt_attrs INTO ls_attr
          WITH KEY cmpname = &lt;att&gt;-name.                    &quot;#EC *
      ENDIF.

      MOVE-CORRESPONDING &lt;att&gt; TO ls_attd.
      ls_attd-description = ls_attr-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;attribute&apos;
          is_struc = ls_attd
          ib_end   = abap_false.
      IF NOT ls_attr IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = &apos;att-ddic&apos;
            is_struc = ls_attr.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;inheritance&apos;
              is_struc = ls_relkey.
        ENDIF.
      ENDIF.

      IF &lt;att&gt;-is_interface EQ abap_true.
        ls_doku-id = &apos;IA&apos;.
      ELSE.
        ls_doku-id = &apos;CA&apos;.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = &lt;att&gt;-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. &quot;attribute
    ENDLOOP.



    LOOP AT lr_descr-&gt;methods ASSIGNING &lt;mth&gt;.

      CLEAR:
        ls_meth,
        ls_relkey,
        ls_cmpkey.

      IF NOT &lt;mth&gt;-alias_for IS INITIAL.
*       ...
      ELSEIF &lt;mth&gt;-is_inherited  EQ abap_true OR
           ( &lt;mth&gt;-is_interface  EQ abap_true AND
             lr_descr-&gt;type_kind NE lr_descr-&gt;typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = &lt;mth&gt;-name.
        CALL FUNCTION &apos;SEO_COMPONENT_BY_INHERITANCE&apos;
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION &apos;SEO_METHOD_SIGNATURE_GET&apos;
          EXPORTING
            mtdkey     = ls_cmpkey
          IMPORTING
            method     = ls_meth
            PARAMETERS = lt_methpar2
            exceps     = lt_methexc2
          EXCEPTIONS
            OTHERS     = 0.
      ELSE.
        READ TABLE lt_meth INTO ls_meth
          WITH KEY cmpname = &lt;mth&gt;-name.                    &quot;#EC *
        REFRESH: lt_methpar2, lt_methexc2.
        LOOP AT lt_methpar ASSIGNING &lt;par&gt;
          WHERE cmpname EQ ls_meth-cmpname.
          APPEND &lt;par&gt; TO lt_methpar2.
        ENDLOOP.
        LOOP AT lt_methexc ASSIGNING &lt;exc&gt;
          WHERE cmpname EQ ls_meth-cmpname.
          APPEND &lt;exc&gt; TO lt_methexc2.
        ENDLOOP.
      ENDIF.

      MOVE-CORRESPONDING &lt;mth&gt; TO ls_mthd.
      ls_mthd-description = ls_meth-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;method&apos;
          is_struc = ls_mthd
          ib_end   = abap_false.
      IF NOT ls_meth IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = &apos;meth-ddic&apos;
            is_struc = ls_meth.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;inheritance&apos;
              is_struc = ls_relkey.
        ENDIF.

        LOOP AT &lt;mth&gt;-parameters ASSIGNING &lt;pr&gt;.
          READ TABLE lt_methpar2 ASSIGNING &lt;par&gt;
            WITH KEY clsname = ls_meth-clsname
                     cmpname = ls_meth-cmpname
                     sconame = &lt;pr&gt;-name.
          MOVE-CORRESPONDING &lt;pr&gt; TO ls_pard.
          ls_pard-description = &lt;par&gt;-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;parameter&apos;
              is_struc = ls_pard
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;par-ddic&apos;
              is_struc = &lt;par&gt;.
          CALL METHOD end_tag. &quot;method
        ENDLOOP.
        LOOP AT &lt;mth&gt;-exceptions ASSIGNING &lt;ex&gt;.
          READ TABLE lt_methexc2 ASSIGNING &lt;exc&gt;
            WITH KEY clsname = ls_meth-clsname
                     cmpname = ls_meth-cmpname
                     sconame = &lt;ex&gt;-name.
          MOVE-CORRESPONDING &lt;ex&gt; TO ls_excd.
          ls_excd-description = &lt;exc&gt;-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;exception&apos;
              is_struc = ls_excd
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;exc-ddic&apos;
              is_struc = &lt;exc&gt;.
          CALL METHOD end_tag. &quot; exception
        ENDLOOP.
      ENDIF.

      IF &lt;mth&gt;-is_interface EQ abap_true.
        ls_doku-id = &apos;IO&apos;.
      ELSE.
        ls_doku-id = &apos;CO&apos;.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = &lt;mth&gt;-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. &quot;method
    ENDLOOP.



    LOOP AT lr_descr-&gt;events ASSIGNING &lt;evt&gt;.
      CLEAR: ls_event, ls_relkey, ls_cmpkey.
      IF NOT &lt;evt&gt;-alias_for IS INITIAL.
*       ...
      ELSEIF &lt;evt&gt;-is_inherited  EQ abap_true OR
           ( &lt;evt&gt;-is_interface  EQ abap_true AND
             lr_descr-&gt;type_kind NE lr_descr-&gt;typekind_intf ).
        ls_reltype-clsname = ic_name.
        ls_reltype-cpdname = &lt;evt&gt;-name.
        CALL FUNCTION &apos;SEO_COMPONENT_BY_INHERITANCE&apos;
          EXPORTING
            cpdkey = ls_reltype
          IMPORTING
            relkey = ls_relkey
            cmpkey = ls_cmpkey
          EXCEPTIONS
            OTHERS = 0.
        CALL FUNCTION &apos;SEO_EVENT_SIGNATURE_GET&apos;
          EXPORTING
            evtkey     = ls_cmpkey
          IMPORTING
            event      = ls_event
            PARAMETERS = lt_methpar2
          EXCEPTIONS
            OTHERS     = 0.
      ELSE.
        READ TABLE lt_evt INTO ls_event
          WITH KEY cmpname = &lt;evt&gt;-name.                    &quot;#EC *
        REFRESH lt_methpar2.
        LOOP AT lt_methpar ASSIGNING &lt;par&gt;
          WHERE cmpname EQ ls_event-cmpname.
          APPEND &lt;par&gt; TO lt_methpar2.
        ENDLOOP.
      ENDIF.
      APPEND INITIAL LINE TO lt_methpar2 ASSIGNING &lt;par&gt;.
      IF NOT ls_cmpkey IS INITIAL.
        MOVE-CORRESPONDING ls_cmpkey TO &lt;par&gt;.
      ELSE.
        MOVE-CORRESPONDING ls_event TO &lt;par&gt;.
      ENDIF.
      &lt;par&gt;-sconame    = &apos;SENDER&apos;.
      &lt;par&gt;-version    = &apos;1&apos;. &quot;active
      &lt;par&gt;-langu      = mc_langu.
      &lt;par&gt;-descript   = &apos;Implicitly added sender of the event&apos;(001).
      &lt;par&gt;-cmptype    = &apos;2&apos;. &quot;method
      &lt;par&gt;-mtdtype    = &apos;0&apos;. &quot;regular method
      &lt;par&gt;-editorder  = &apos;0&apos;.
      &lt;par&gt;-dispid     = &apos;0&apos;.
      &lt;par&gt;-author     = ls_event-author.
      &lt;par&gt;-createdon  = ls_event-createdon.
      &lt;par&gt;-changedby  = ls_event-changedby.
      &lt;par&gt;-changedon  = ls_event-changedon.
      &lt;par&gt;-pardecltyp = &apos;1&apos;. &quot;always exporting
      &lt;par&gt;-parpasstyp = &apos;0&apos;. &quot;always by-value
      &lt;par&gt;-typtype    = &apos;3&apos;. &quot;TYPE REF TO
      &lt;par&gt;-type       = ic_name.
*      &lt;par&gt;-TABLEOF
*      &lt;par&gt;-PARVALUE
*      &lt;par&gt;-PAROPTIONL
*      &lt;par&gt;-PARPREFERD
*      &lt;par&gt;-LOCKED

      MOVE-CORRESPONDING &lt;evt&gt; TO ls_evtd.
      ls_evtd-description = ls_event-descript.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;event&apos;
          is_struc = ls_evtd
          ib_end   = abap_false.
      IF NOT ls_event IS INITIAL.
        CALL METHOD write_tag
          EXPORTING
            ic_tag   = &apos;evt-ddic&apos;
            is_struc = ls_event.
        IF NOT ls_relkey IS INITIAL.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;inheritance&apos;
              is_struc = ls_relkey.
        ENDIF.

        LOOP AT &lt;evt&gt;-parameters ASSIGNING &lt;pr&gt;.
          READ TABLE lt_methpar2 ASSIGNING &lt;par&gt;
            WITH KEY clsname = ls_event-clsname
                     cmpname = ls_event-cmpname
                     sconame = &lt;pr&gt;-name.
          MOVE-CORRESPONDING &lt;pr&gt; TO ls_pard.
          ls_pard-description = &lt;par&gt;-descript.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;parameter&apos;
              is_struc = ls_pard
              ib_end   = abap_false.
          CALL METHOD write_tag
            EXPORTING
              ic_tag   = &apos;par-ddic&apos;
              is_struc = &lt;par&gt;.
          CALL METHOD end_tag. &quot;method
        ENDLOOP.
      ENDIF.

      IF &lt;evt&gt;-is_interface EQ abap_true.
        ls_doku-id = &apos;IE&apos;.
      ELSE.
        ls_doku-id = &apos;CE&apos;.
      ENDIF.
      IF NOT ls_cmpkey IS INITIAL.
        ls_doku-object    = ls_cmpkey.
      ELSE.
        ls_doku-object    = ic_name.
        ls_doku-object+30 = &lt;evt&gt;-name.
      ENDIF.
      CALL METHOD process_documentation
        EXPORTING
          ic_name  = ls_doku-object
          ic_dokid = ls_doku-id.

      CALL METHOD end_tag. &quot;method
    ENDLOOP.

  ENDMETHOD.                    &quot;process_object_body



  METHOD get_table_content.

    DATA:
      lr_content TYPE REF TO data.
    FIELD-SYMBOLS:
      &lt;content&gt;  TYPE ANY.

    CREATE DATA lr_content TYPE (ic_name).
    ASSIGN lr_content-&gt;* TO &lt;content&gt;.
    SELECT * FROM (ic_name) INTO &lt;content&gt;.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = &apos;entry&apos;
          is_struc = &lt;content&gt;.
    ENDSELECT.

  ENDMETHOD.                    &quot;get_table_content



  METHOD write_table.

    FIELD-SYMBOLS &lt;l&gt; TYPE ANY.

    LOOP AT it_table ASSIGNING &lt;l&gt;.
      CALL METHOD write_tag
        EXPORTING
          ic_tag   = ic_tag
          is_struc = &lt;l&gt;.
    ENDLOOP.

  ENDMETHOD.                    &quot;write_table



  METHOD write_tag.

    DATA lr_element TYPE REF TO if_ixml_element.

    lr_element = mr_xml_doc-&gt;create_simple_element( name = ic_tag
      parent = mr_current ).
    INSERT lr_element INTO mt_stack INDEX 1.
    mr_current = lr_element.

    IF is_struc IS SUPPLIED.
      CALL METHOD write_attributes( is_struc ).
    ENDIF.

    IF ib_end EQ abap_true.
      DELETE mt_stack INDEX 1.
      READ TABLE mt_stack INTO mr_current INDEX 1.
    ENDIF.

  ENDMETHOD.                    &quot;write_tag


  METHOD end_tag.

    DELETE mt_stack INDEX 1.
    READ TABLE mt_stack INTO mr_current INDEX 1.

  ENDMETHOD.                    &quot;end_tag


  METHOD write_attributes.

    DATA:
      lr_descr TYPE REF TO cl_abap_structdescr.
    FIELD-SYMBOLS:
      &lt;c&gt;      LIKE LINE OF lr_descr-&gt;components,
      &lt;f&gt;      TYPE ANY.

    lr_descr ?= cl_abap_typedescr=&gt;describe_by_data( is_struc ).

    LOOP AT lr_descr-&gt;components ASSIGNING &lt;c&gt;.
      ASSIGN COMPONENT &lt;c&gt;-name OF STRUCTURE is_struc TO &lt;f&gt;.
      CALL METHOD write_attribute( ic_name = &lt;c&gt;-name i_field = &lt;f&gt; ).
    ENDLOOP.

  ENDMETHOD.                    &quot;write_attributes


  METHOD write_attribute.

    DATA:
      lc_name  TYPE string,
      lc_value TYPE string.

    lc_name = get_attribute_name( ic_name ).
    CHECK NOT lc_name IS INITIAL.
    lc_value = get_attribute_value( ic_name = lc_name
      i_field = i_field ).
    CHECK NOT lc_value IS INITIAL.
    CALL METHOD mr_current-&gt;set_attribute( name = lc_name
      value = lc_value ).

  ENDMETHOD.                    &quot;write_attribute

*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_attribute_name
*&amp;---------------------------------------------------------------------*
  METHOD get_attribute_name.

    IF mr_current-&gt;get_name( ) &lt;&gt; &apos;entry&apos;.
      CHECK ic_name &lt;&gt;: &apos;DDLANGUAGE&apos;, &apos;SPRAS&apos;, &apos;LANGU&apos;,
                        &apos;INTLENGTH&apos;, &apos;EDITORDER&apos;, &apos;R3RELEASE&apos;, &apos;DISPID&apos;,
                        &apos;UUID&apos;.
    ENDIF.

    transl &apos;DDTEXT&apos; &apos;description&apos;.
    transl &apos;DESCRIPT&apos; &apos;description&apos;.
    transl &apos;AS4USER&apos; &apos;changedby&apos;.
    transl &apos;AS4DATE&apos; &apos;changedon&apos;.
    transl &apos;AS4USER&apos; &apos;changedby&apos;.


    CASE mr_current-&gt;get_name( ).
      WHEN &apos;package&apos; OR &apos;subpackage&apos;.
        CHECK ic_name &lt;&gt;: &apos;INTSYS&apos;, &apos;CONSYS&apos;.
        transl &apos;DEVCLASS&apos; &apos;name&apos;.
        transl &apos;CTEXT&apos; &apos;description&apos;.
      WHEN &apos;class&apos; OR &apos;subclass&apos; OR &apos;superclass&apos;.
        CHECK ic_name &lt;&gt;: &apos;LANGU&apos;, &apos;REFCLSNAME&apos;.
        transl &apos;CLSNAME&apos; &apos;name&apos;.
      WHEN &apos;attribute&apos;. &quot;of a class
        CHECK ic_name &lt;&gt;: &apos;LENGTH&apos;, &apos;DECIMALS&apos;.
*        transl &apos;CMPNAME&apos; &apos;name&apos;.
*        transl &apos;ATTDECLTYP&apos; &apos;scope&apos;.
      WHEN &apos;method&apos;. &quot;of a class
        CHECK ic_name &lt;&gt;: &apos;PARAMETERS&apos;, &apos;EXCEPTIONS&apos;.
*        CHECK ic_name NE: &apos;CLSNAME&apos;.
        transl &apos;CMPNAME&apos; &apos;name&apos;.
        transl &apos;MTDDECLTYP&apos; &apos;scope&apos;.
      WHEN &apos;parameter&apos;. &quot;of a function module or class
        CHECK ic_name &lt;&gt;: &apos;POSITION&apos;, &apos;CLSNAME&apos;, &apos;CMPNAME&apos;, &apos;LENGTH&apos;,
                          &apos;DECIMALS&apos;.
        transl &apos;SCONAME&apos; &apos;name&apos;.   &quot;class
        transl &apos;TABNAME&apos; &apos;type&apos;.
        transl &apos;PARAMTEXT&apos; &apos;description&apos;.
      WHEN &apos;event&apos;.
        CHECK ic_name &lt;&gt; &apos;PARAMETERS&apos;.
      WHEN &apos;dataelem&apos;.
        transl &apos;ROLLNAME&apos; &apos;name&apos;.
      WHEN &apos;domain&apos;.
        transl &apos;DOMNAME&apos; &apos;name&apos;.
      WHEN &apos;fixed-value&apos;. &quot;of domain
        CHECK ic_name &lt;&gt;: &apos;DOMNAME&apos;, &apos;VALPOS&apos;.
      WHEN &apos;enqueue-object&apos;.
        transl &apos;VIEWNAME&apos; &apos;name&apos;.
      WHEN &apos;base-table&apos;. &quot;of an enqueue object
        CHECK ic_name &lt;&gt; &apos;VIEWNAME&apos;.
        transl &apos;TABNAME&apos; &apos;type&apos;.
      WHEN &apos;lock-argument&apos;. &quot;of an enqueue object
        CHECK ic_name &lt;&gt; &apos;VIEWNAME&apos;.
      WHEN &apos;lock-parameter&apos;. &quot;of an enqueue object
        CHECK ic_name &lt;&gt; &apos;VIEWNAME&apos;.
      WHEN &apos;function-group&apos;.
        CHECK ic_name &lt;&gt; &apos;DEVCLASS&apos;.
        transl &apos;AREA&apos; &apos;name&apos;.
        transl &apos;AREAT&apos; &apos;description&apos;.
      WHEN &apos;function-module&apos;.
        CHECK ic_name &lt;&gt; &apos;AREA&apos;.
        transl &apos;FUNCNAME&apos; &apos;name&apos;.
        transl &apos;STEXT&apos; &apos;description&apos;.
      WHEN &apos;importing&apos; OR &apos;exporting&apos; OR &apos;changing&apos; OR &apos;tables&apos;.
        transl &apos;PARAMETER&apos; &apos;name&apos;.
        transl &apos;TYP&apos; &apos;type&apos;.
        transl &apos;DBFIELD&apos; &apos;type&apos;.
        transl &apos;DBSTRUCT&apos; &apos;type&apos;.
      WHEN &apos;exception&apos;.
        transl &apos;EXCEPTION&apos; &apos;name&apos;.
      WHEN &apos;interface&apos;.
        transl &apos;CLSNAME&apos; &apos;name&apos;.
      WHEN &apos;table&apos;.
        transl &apos;TABNAME&apos; &apos;name&apos;.
        transl &apos;ROLLNAME&apos; &apos;type&apos;.
      WHEN &apos;component&apos;. &quot;of a table or structure
        CHECK ic_name &lt;&gt;: &apos;TABNAME&apos;, &apos;POSITION&apos;, &apos;OFFSET&apos;.
        transl &apos;FIELDNAME&apos; &apos;name&apos;.
        transl &apos;ROLLNAME&apos; &apos;type&apos;.
      WHEN &apos;table-type&apos;.
        transl &apos;TYPENAME&apos; &apos;name&apos;.
        transl &apos;ROWTYPE&apos; &apos;type&apos;.
      WHEN &apos;key&apos;. &quot;of table-type.
        CHECK ic_name &lt;&gt; &apos;TYPENAME&apos;.

    ENDCASE.

    IF ec_name IS INITIAL. &quot;none of previous translations applied
      ec_name = ic_name.
      TRANSLATE ec_name TO LOWER CASE.
    ENDIF.

  ENDMETHOD.                    &quot;write_attribute_name


*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_attribute_value
*&amp;---------------------------------------------------------------------*
  METHOD get_attribute_value.

    DATA:
      lc(100)    TYPE c,
      ls_address TYPE bapiaddr3,
      lt_return  TYPE bapiret2_t.

    WRITE i_field TO lc LEFT-JUSTIFIED.

    IF lc IS INITIAL. &quot;initial in character mode, i.e. lc is space

      CHECK mr_current-&gt;get_name( ) = &apos;fixed-value&apos; OR
            mr_current-&gt;get_name( ) = &apos;entry&apos;.

      ec_value = &apos;&quot; &quot;&apos;.
      EXIT.

    ELSEIF lc = &apos;00.00.0000&apos;.
*     Ignore initial dates
      EXIT.

    ELSEIF ic_name = &apos;author&apos; OR
           ic_name = &apos;changedby&apos;.

      CALL FUNCTION &apos;BAPI_USER_GET_DETAIL&apos;
        EXPORTING
          username = i_field
        IMPORTING
          address  = ls_address
        TABLES
          return   = lt_return.
      IF NOT ls_address-firstname IS INITIAL OR
         NOT ls_address-lastname IS INITIAL.
        CONCATENATE ls_address-firstname ls_address-lastname INTO lc
          SEPARATED BY space.
        CONDENSE lc.
      ENDIF.

    ENDIF.

    ec_value = lc.

  ENDMETHOD.                    &quot;get_attribute_value


  METHOD get_superclass .

    CLEAR ec_superclass.

    DATA:
      lr_descr TYPE REF TO cl_abap_typedescr,
      lr_class TYPE REF TO cl_abap_classdescr.

    CALL METHOD cl_abap_typedescr=&gt;describe_by_name
      EXPORTING
        p_name      = ic_classname
      RECEIVING
        p_descr_ref = lr_descr
      EXCEPTIONS
        OTHERS      = 1.
    CHECK sy-subrc EQ 0.

    CATCH SYSTEM-EXCEPTIONS move_cast_error = 1.
      lr_class ?= lr_descr.
    ENDCATCH.
    CHECK sy-subrc = 0.

    CALL METHOD lr_class-&gt;get_super_class_type
      RECEIVING
        p_descr_ref = lr_descr
      EXCEPTIONS
        OTHERS      = 1.
    CHECK: sy-subrc     = 0,
           NOT lr_descr IS INITIAL. &quot;no superclass

    ec_superclass = lr_descr-&gt;get_relative_name( ).

  ENDMETHOD.                    &quot;GET_SUPERCLASS

  METHOD check_class_syntax.

    DATA:
      lr_naming          TYPE REF TO if_oo_clif_incl_naming,
      lt_source          TYPE STANDARD TABLE OF edpline,
      lc_message         TYPE text240,                      &quot;#EC NEEDED
      li_line            TYPE i,                            &quot;#EC NEEDED
      lc_word            TYPE edpline.                      &quot;#EC NEEDED

    CALL METHOD cl_oo_include_naming=&gt;get_instance_by_cifkey
      EXPORTING
        cifkey = is_class
      RECEIVING
        cifref = lr_naming
      EXCEPTIONS
        OTHERS = 1.
    CHECK sy-subrc = 0.

    READ REPORT lr_naming-&gt;pool INTO lt_source.
    CHECK sy-subrc = 0.

    SYNTAX-CHECK FOR lt_source
      MESSAGE lc_message
      LINE li_line
      WORD lc_word
      PROGRAM lr_naming-&gt;pool.
    CHECK sy-subrc = 0.

    eb_check_succeeded = abap_true.

  ENDMETHOD.                    &quot;check_class_syntax

ENDCLASS.                    &quot;ycl_generator IMPLEMENTATION</source>
</PROG>
